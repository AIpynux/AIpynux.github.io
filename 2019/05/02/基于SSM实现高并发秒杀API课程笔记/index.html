<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="基于SSM实现高并发秒杀API课程笔记"><meta name="keywords" content="SSM"><meta name="author" content="红发,undefined"><meta name="copyright" content="红发"><meta name="google-site-verification" content="2qD2H53mq7Q4fWHTe_H9huItL7XaHmouHFJTHndTAPw"><meta name="baidu-site-verification" content="ZHTWfF4ogJ"><meta name="msvalidate.01" content="C180334B457FBE8FF36C78400C2C216E"><title>基于SSM实现高并发秒杀API课程笔记 | 红发</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#课程概述"><span class="toc-number">1.</span> <span class="toc-text">课程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用SSM框架"><span class="toc-number">1.1.</span> <span class="toc-text">为什么使用SSM框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么选用秒杀类系统进行讲解"><span class="toc-number">1.2.</span> <span class="toc-text">为什么选用秒杀类系统进行讲解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务的四大特性"><span class="toc-number">1.3.</span> <span class="toc-text">事务的四大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性-atomicity"><span class="toc-number">1.3.1.</span> <span class="toc-text">原子性(atomicity):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一致性-consistency"><span class="toc-number">1.3.2.</span> <span class="toc-text">一致性(consistency):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#隔离性-isolation"><span class="toc-number">1.3.3.</span> <span class="toc-text">隔离性(isolation):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#持久性-durability"><span class="toc-number">1.3.4.</span> <span class="toc-text">持久性(durability):</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关技术要求"><span class="toc-number">1.4.</span> <span class="toc-text">相关技术要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL"><span class="toc-number">1.4.1.</span> <span class="toc-text">MySQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis"><span class="toc-number">1.4.2.</span> <span class="toc-text">MyBatis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring"><span class="toc-number">1.4.3.</span> <span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">1.4.4.</span> <span class="toc-text">Spring MVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前端"><span class="toc-number">1.4.5.</span> <span class="toc-text">前端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高并发"><span class="toc-number">1.4.6.</span> <span class="toc-text">高并发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#学习成果"><span class="toc-number">1.5.</span> <span class="toc-text">学习成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSM整合与使用"><span class="toc-number">2.</span> <span class="toc-text">SSM整合与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于Maven创建项目"><span class="toc-number">2.1.</span> <span class="toc-text">基于Maven创建项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#要点"><span class="toc-number">2.1.1.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#官网地址"><span class="toc-number">2.1.2.</span> <span class="toc-text">官网地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Maven命令创建Web骨架项目"><span class="toc-number">2.1.3.</span> <span class="toc-text">使用Maven命令创建Web骨架项目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#业务分析与DAO层"><span class="toc-number">3.</span> <span class="toc-text">业务分析与DAO层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#秒杀业务分析"><span class="toc-number">3.1.</span> <span class="toc-text">秒杀业务分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户针对库存业务分析"><span class="toc-number">3.2.</span> <span class="toc-text">用户针对库存业务分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用户购买行为"><span class="toc-number">3.2.1.</span> <span class="toc-text">用户购买行为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于数据落地"><span class="toc-number">3.3.</span> <span class="toc-text">关于数据落地</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL实现秒杀系统难点"><span class="toc-number">3.4.</span> <span class="toc-text">MySQL实现秒杀系统难点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统要实现的秒杀功能"><span class="toc-number">3.5.</span> <span class="toc-text">系统要实现的秒杀功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码开发阶段"><span class="toc-number">3.6.</span> <span class="toc-text">代码开发阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库表设计"><span class="toc-number">3.7.</span> <span class="toc-text">数据库表设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DAO层接口设计和编码"><span class="toc-number">3.8.</span> <span class="toc-text">DAO层接口设计和编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实体设计"><span class="toc-number">3.8.1.</span> <span class="toc-text">实体设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DAO接口设计"><span class="toc-number">3.8.2.</span> <span class="toc-text">DAO接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于MyBatis实现DAO理论"><span class="toc-number">3.8.3.</span> <span class="toc-text">基于MyBatis实现DAO理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于MyBatis实现DAO编程"><span class="toc-number">3.8.4.</span> <span class="toc-text">基于MyBatis实现DAO编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis整合Spring理论"><span class="toc-number">3.8.5.</span> <span class="toc-text">MyBatis整合Spring理论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#整合目标"><span class="toc-number">3.8.5.1.</span> <span class="toc-text">整合目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#整合步骤"><span class="toc-number">3.8.5.2.</span> <span class="toc-text">整合步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis整合Spring编码"><span class="toc-number">3.8.6.</span> <span class="toc-text">MyBatis整合Spring编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DAO层单元测试编码与问题排查"><span class="toc-number">3.8.7.</span> <span class="toc-text">DAO层单元测试编码与问题排查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service层"><span class="toc-number">4.</span> <span class="toc-text">Service层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#完成DAO层后的思考"><span class="toc-number">4.1.</span> <span class="toc-text">完成DAO层后的思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service层设计和开发"><span class="toc-number">4.2.</span> <span class="toc-text">Service层设计和开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Service接口设计"><span class="toc-number">4.2.1.</span> <span class="toc-text">Service接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service接口实现"><span class="toc-number">4.2.2.</span> <span class="toc-text">Service接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Spring托管Service依赖理论"><span class="toc-number">4.2.3.</span> <span class="toc-text">使用Spring托管Service依赖理论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-IOC-依赖注入-理解"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">Spring IOC(依赖注入)理解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本项目IOC使用"><span class="toc-number">4.2.4.</span> <span class="toc-text">本项目IOC使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Spring托管Service依赖配置"><span class="toc-number">4.2.5.</span> <span class="toc-text">使用Spring托管Service依赖配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring声明式事务"><span class="toc-number">4.2.6.</span> <span class="toc-text">Spring声明式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#配置并使用Spring声明式事务"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">配置并使用Spring声明式事务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集成测试Service逻辑"><span class="toc-number">4.2.7.</span> <span class="toc-text">集成测试Service逻辑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web层设计与实现"><span class="toc-number">5.</span> <span class="toc-text">Web层设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前端交互流程设计"><span class="toc-number">5.1.</span> <span class="toc-text">前端交互流程设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前端页面流程"><span class="toc-number">5.1.1.</span> <span class="toc-text">前端页面流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#详情页面流程"><span class="toc-number">5.1.2.</span> <span class="toc-text">详情页面流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#学习Restful接口设计"><span class="toc-number">5.2.</span> <span class="toc-text">学习Restful接口设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Restful"><span class="toc-number">5.2.1.</span> <span class="toc-text">什么是Restful</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Restful规范"><span class="toc-number">5.2.2.</span> <span class="toc-text">Restful规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Restful的URL设计"><span class="toc-number">5.2.3.</span> <span class="toc-text">Restful的URL设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#秒杀API的URL设计"><span class="toc-number">5.2.4.</span> <span class="toc-text">秒杀API的URL设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">5.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC整合Spring"><span class="toc-number">5.3.</span> <span class="toc-text">Spring MVC整合Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Spring-MVC框架理论"><span class="toc-number">5.3.1.</span> <span class="toc-text">使用Spring MVC框架理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC运行流程"><span class="toc-number">5.3.2.</span> <span class="toc-text">Spring MVC运行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP请求地址映射原理"><span class="toc-number">5.3.3.</span> <span class="toc-text">HTTP请求地址映射原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#注解映射技巧"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">注解映射技巧</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC请求方法细节处理"><span class="toc-number">5.3.4.</span> <span class="toc-text">Spring MVC请求方法细节处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整合配置Spring-MVC框架"><span class="toc-number">5.3.5.</span> <span class="toc-text">整合配置Spring MVC框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现秒杀相关的Restful接口"><span class="toc-number">5.4.</span> <span class="toc-text">实现秒杀相关的Restful接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于bootstrap开发页面结构"><span class="toc-number">5.5.</span> <span class="toc-text">基于bootstrap开发页面结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交互逻辑编程"><span class="toc-number">5.6.</span> <span class="toc-text">交互逻辑编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie登录交互"><span class="toc-number">5.6.1.</span> <span class="toc-text">cookie登录交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计时交互设计"><span class="toc-number">5.6.2.</span> <span class="toc-text">计时交互设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#秒杀交互设计"><span class="toc-number">5.6.3.</span> <span class="toc-text">秒杀交互设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web层总结"><span class="toc-number">5.7.</span> <span class="toc-text">Web层总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前端交互设计过程"><span class="toc-number">5.7.1.</span> <span class="toc-text">前端交互设计过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Restful接口设计"><span class="toc-number">5.7.2.</span> <span class="toc-text">Restful接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC使用技巧"><span class="toc-number">5.7.3.</span> <span class="toc-text">Spring MVC使用技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BootStrap和JavaScript使用"><span class="toc-number">5.7.4.</span> <span class="toc-text">BootStrap和JavaScript使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高并发优化"><span class="toc-number">6.</span> <span class="toc-text">高并发优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis后端缓存优化编码"><span class="toc-number">6.1.</span> <span class="toc-text">redis后端缓存优化编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发优化"><span class="toc-number">6.2.</span> <span class="toc-text">并发优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优化"><span class="toc-number">6.3.</span> <span class="toc-text">深度优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统部署架构"><span class="toc-number">6.4.</span> <span class="toc-text">系统部署架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#课程总结"><span class="toc-number">7.</span> <span class="toc-text">课程总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据层技术回顾"><span class="toc-number">7.1.</span> <span class="toc-text">数据层技术回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#业务层技术回顾"><span class="toc-number">7.2.</span> <span class="toc-text">业务层技术回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WEB技术回顾"><span class="toc-number">7.3.</span> <span class="toc-text">WEB技术回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发优化-1"><span class="toc-number">7.4.</span> <span class="toc-text">并发优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">8.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Avatar/Avatar.jpg"></div><div class="author-info__name text-center">红发</div><div class="author-info__description text-center">学习Java后端开发中</div><div class="follow-button"><a href="https://github.com/AIpynux" target="_blank">关注我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">红发</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div><div id="post-info"><div id="post-title">基于SSM实现高并发秒杀API课程笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/编程笔记/">编程笔记</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">11.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 40 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><h3 id="为什么使用SSM框架"><a href="#为什么使用SSM框架" class="headerlink" title="为什么使用SSM框架"></a>为什么使用SSM框架</h3><ul>
<li>易用且轻便 </li>
<li>互联网公司常用</li>
<li>低业务代码侵入性</li>
<li>成熟的社区和用户群</li>
</ul>
<h3 id="为什么选用秒杀类系统进行讲解"><a href="#为什么选用秒杀类系统进行讲解" class="headerlink" title="为什么选用秒杀类系统进行讲解"></a>为什么选用秒杀类系统进行讲解</h3><ul>
<li>秒杀类业务场景具有典型的”事务”特性</li>
<li>秒杀和红包类需求越来越常见</li>
<li>面试常问问题</li>
</ul>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><h4 id="原子性-atomicity"><a href="#原子性-atomicity" class="headerlink" title="原子性(atomicity):"></a>原子性(atomicity):</h4><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
<h4 id="一致性-consistency"><a href="#一致性-consistency" class="headerlink" title="一致性(consistency):"></a>一致性(consistency):</h4><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，前面执行的一、二语句也不会生效。因为事务最终没有提交，所以事务中所做的修改都不会保存到数据库中。</p>
<h4 id="隔离性-isolation"><a href="#隔离性-isolation" class="headerlink" title="隔离性(isolation):"></a>隔离性(isolation):</h4><p>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。当执行第三条语句、第四条语句还未开始时，此时有另外一个程序开始运行，则看不到第三条语句做出的改变。</p>
<h4 id="持久性-durability"><a href="#持久性-durability" class="headerlink" title="持久性(durability):"></a>持久性(durability):</h4><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到100%的持久性保证策略。</p>
<h3 id="相关技术要求"><a href="#相关技术要求" class="headerlink" title="相关技术要求"></a>相关技术要求</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ul>
<li>SQL技巧</li>
<li>事务和行级锁</li>
<li>表设计(手写代码)</li>
</ul>
<h4 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h4><ul>
<li>DAO层设计与开发</li>
<li>MyBatis合理使用</li>
<li>MyBatis与Spring整合</li>
</ul>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul>
<li>Spring IOC整合Service</li>
<li>声明式事务运用</li>
</ul>
<h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><ul>
<li>框架运作流程</li>
<li>Restful接口设计和使用</li>
<li>Controller开发技巧</li>
</ul>
<h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><ul>
<li>交互设计</li>
<li>Bootstrap</li>
<li>JQuery</li>
</ul>
<h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><ul>
<li>高并发点和高并发分析</li>
<li>优化思路并实现</li>
</ul>
<h3 id="学习成果"><a href="#学习成果" class="headerlink" title="学习成果"></a>学习成果</h3><ul>
<li>SSM整合与使用</li>
<li>秒杀类系统需求理解与实现</li>
<li>常用场景高并发解决方案</li>
</ul>
<h2 id="SSM整合与使用"><a href="#SSM整合与使用" class="headerlink" title="SSM整合与使用"></a>SSM整合与使用</h2><h3 id="基于Maven创建项目"><a href="#基于Maven创建项目" class="headerlink" title="基于Maven创建项目"></a>基于Maven创建项目</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul>
<li>项目从零开始创建</li>
<li>从官网获取相关配置</li>
<li>使用Maven创建项目  <h4 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h4>Logback配置：<a href="https://logback.qos.ch/manual/configuration.html" target="_blank" rel="noopener">https://logback.qos.ch/manual/configuration.html</a><br>Spring配置：<a href="https://docs.spring.io/spring/docs/" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/</a><br>MyBatis配置：<a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/index.html</a>  <h4 id="使用Maven命令创建Web骨架项目"><a href="#使用Maven命令创建Web骨架项目" class="headerlink" title="使用Maven命令创建Web骨架项目"></a>使用Maven命令创建Web骨架项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=org.seckill -DartifactId=seckill -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：archetype:create这个goal已在新版本Maven中弃用。</p>
<ol>
<li>pom.xml是Maven项目的配置文件。</li>
<li>使用Maven创建的项目中的web.xml中Servlet版本可能过低，我们通过复制Servlet容器服务器如Tomcat的实例目录中的WEB-INF中的web.xml高版本的文件头进行替换。  </li>
<li>补全项目目录(src-main-java、src-test、src-test-java和src-test-resources)。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1.png" alt=""></li>
<li>改变pom.xml下默认junit依赖版本为4.11，因为junit3使用编程方式测试，而junit4使用注解方式进行测试。</li>
<li>补全项目依赖。</li>
</ol>
<ul>
<li><p>日志(slf4j,log4j,logback,common-logging)：slf4j是规范/接口;log4j,logback,common-logging是日志实现;\<br>常用组合：slf4j + logback。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实现slf4j接口并整合进来，编程时只需使用slf4j(使用其他日志实现时也会有个类似这样进行整合的依赖，所以编程时都能统一使用slf4j) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库(数据库驱动和数据库连接池)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DAO框架(MyBatis本身依赖和MyBatis与Spring整合依赖)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MyBatis自身实现的与Spring之间的整合依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Servlet Web相关依赖(JSP相关标签库,jackson和Servlet依赖)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jackson依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring依赖(4大方面)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1) Spring核心依赖 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 包含SpringIOC依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring扩展(如包扫描)依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2) Spring DAO层依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 需要Spring-jdbc提供的事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 需要Spring-tx提供的声明式事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3) Spring Web相关依赖(容器需要加载Spring IOC和Spring AOP来启动Spring的工厂) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;<span class="name">nversion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4) Spring test相关依赖,方便我们使用junit做单元测试和集成测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="业务分析与DAO层"><a href="#业务分析与DAO层" class="headerlink" title="业务分析与DAO层"></a>业务分析与DAO层</h2><h3 id="秒杀业务分析"><a href="#秒杀业务分析" class="headerlink" title="秒杀业务分析"></a>秒杀业务分析</h3><p>秒杀业务的核心：对库存的处理<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2.png" alt=""></p>
<h3 id="用户针对库存业务分析"><a href="#用户针对库存业务分析" class="headerlink" title="用户针对库存业务分析"></a>用户针对库存业务分析</h3><p><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/3.png" alt=""></p>
<h4 id="用户购买行为"><a href="#用户购买行为" class="headerlink" title="用户购买行为"></a>用户购买行为</h4><p><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/4.png" alt=""></p>
<h3 id="关于数据落地"><a href="#关于数据落地" class="headerlink" title="关于数据落地"></a>关于数据落地</h3><p>不加事务会造成超卖和少卖的情况<br>NoSQL相比MySQL，虽然分化注重了高可用、高并发和分布式的特性，但是事务支持性差。</p>
<h3 id="MySQL实现秒杀系统难点"><a href="#MySQL实现秒杀系统难点" class="headerlink" title="MySQL实现秒杀系统难点"></a>MySQL实现秒杀系统难点</h3><p>多个用户参与活动时产生竞争，竞争反应到MySQL背后的技术是事务和行级锁。<br>这一事务由Start Transaction、Upate 库存数量、Insert 购买明细和Commit组成。<br>主要的行级锁位于Update 库存数量时。而系统的难点就是如何高效的去处理这样的竞争。</p>
<h3 id="系统要实现的秒杀功能"><a href="#系统要实现的秒杀功能" class="headerlink" title="系统要实现的秒杀功能"></a>系统要实现的秒杀功能</h3><ul>
<li>秒杀相关查询</li>
<li>秒杀接口暴露</li>
<li>执行秒杀</li>
</ul>
<h3 id="代码开发阶段"><a href="#代码开发阶段" class="headerlink" title="代码开发阶段"></a>代码开发阶段</h3><ol>
<li>DAO设计编码(数据库表设计、DAO接口和MyBatis实现DAO)</li>
<li>Service设计编码(Service接口、Spring管理Service和通过声明式事务简化事务控制)</li>
<li>Web设计编码(Restful接口和前端交互)</li>
</ol>
<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><ol>
<li>手写DDL让同行间的交流更加方便。</li>
<li>MySQL提供可选的引擎有很多，但支持事务的只有InnoDB。</li>
<li>MySQL 5.7 及以后的版本中explicit_defaults_for_timestamp的值默认都是OFF。</li>
</ol>
<h3 id="DAO层接口设计和编码"><a href="#DAO层接口设计和编码" class="headerlink" title="DAO层接口设计和编码"></a>DAO层接口设计和编码</h3><p>已设计的数据表对应Java中的实体。<br>给实体和DAO接口创建好包。</p>
<h4 id="实体设计"><a href="#实体设计" class="headerlink" title="实体设计"></a>实体设计</h4><p>注意变通，在SuccessKilled实体中需要拿到Seckill实体，其实这个意味着多对一的复合属性。</p>
<h4 id="DAO接口设计"><a href="#DAO接口设计" class="headerlink" title="DAO接口设计"></a>DAO接口设计</h4><ol>
<li>DAO层关注着数据库操作。</li>
<li>接口命名规范：实体名+DAO。</li>
<li>接口设计其实对应着数据的增删改查，并且接口内方法的设计也有相应规范。</li>
<li>具体接口的实现可以用JDBC或Hibernate或MyBatis。</li>
</ol>
<h4 id="基于MyBatis实现DAO理论"><a href="#基于MyBatis实现DAO理论" class="headerlink" title="基于MyBatis实现DAO理论"></a>基于MyBatis实现DAO理论</h4><ol>
<li>MyBatis完成的是实体对象与数据库间的映射工作(OR Mapping)。</li>
<li>MyBatis需要我们提供参数和SQL(Hibernate没有)，之后它返回给我们结果。</li>
<li>SQL可以写在xml文件中或着注解当中，写在xml文件中比较灵活轻便。</li>
<li>DAO接口可以通过MyBatis中的Mapper机制自动实现(推荐)，也可以通过API编程方式自己实现接口。</li>
</ol>
<h4 id="基于MyBatis实现DAO编程"><a href="#基于MyBatis实现DAO编程" class="headerlink" title="基于MyBatis实现DAO编程"></a>基于MyBatis实现DAO编程</h4><ol>
<li>在src-resources目录下创建全局的MyBatis配置文件mybatis-config.xml。</li>
<li>在src-resources目录下创建放置MyBatis映射文件的mapper目录。</li>
<li>从MyBatis官网获取配置头文件。</li>
<li>设置useGeneratedKeys的值为true，让MyBatis可以使用JDBC的getGeneratedKeys获取数据库自增主键值。</li>
<li>设置可以使用列别名替换列名使用(useColumnLabel默认为true)，这样MyBatis自动帮我们实现实体属性与表属性间的转换(select name as title from table)。</li>
<li>设置开启(mapUnderscoreToCamelCase)驼峰命名转换(Table(create_time) -&gt; Entity(createTime))。</li>
<li>mapper目录中的xml文件能为DAO接口方法提供SQL语句配置。</li>
<li>xml文件中有相应标签(insert、delete、update和select)对应方法要实现的增删改查。</li>
<li>xml文件中不允许有&lt;=这样的语法，我们在写SQL语句时可以用&lt;![CDATA[&lt;=]]&gt;来告诉xml这里的&lt;=不是xml的语法，这样就能用了。</li>
<li>resultType类型如果是自创的实体，在表示的时候可以先不写包名只写类名，因为后面的配置中可以给出一个包名的环境变量。</li>
<li>如果方法中的返回类型是List这样的泛型，在写resultType时直接写List里面包含的对象类型，如这里的项目中是List包含的是自创的实体类型Seckill。</li>
<li>SQL语句中可以用limit来限制查询结果的行数。</li>
<li>insert时如果主键重复会报错，我们可以忽略主键重复(ignore)报错而返回0，让我们更好的去处理这个逻辑。</li>
<li>用inner join … on …链接可以将一个实体属性带入另一个实体。</li>
<li>这样的链接语句其实也是体现MyBatis技巧的一个载体(它能告诉MyBatis把结果映射到两个不同实体)。</li>
<li>表的别名设置时可以省略as关键字，表的别名可以与驼峰命名转换机制组合使用。</li>
<li>MyBatis可以通过列别名与当前实体中另一实体类对象属性组合的方式来映射到另一个实体。</li>
<li>上述的列别名组合实际上可以理解为一个el表达式。</li>
<li>MyBatis相对其他ORM框架的优势在于可以让我们自由控制SQL，完美地发挥我们工程师的SQL技巧。</li>
</ol>
<h4 id="MyBatis整合Spring理论"><a href="#MyBatis整合Spring理论" class="headerlink" title="MyBatis整合Spring理论"></a>MyBatis整合Spring理论</h4><h5 id="整合目标"><a href="#整合目标" class="headerlink" title="整合目标"></a>整合目标</h5><ol>
<li>更少的编码<br>体现：只写接口，不写实现类(MyBatis为我们实现)。<br>理由：接口就能告诉我们很多事情：方法的结果集、行为和参数。</li>
<li>更少的配置<br>体现：自动实现DAO实现类并注入到Spring容器。</li>
<li>足够的灵活<br>体现：整合之后我们依然可以灵活的自己定制SQL。</li>
</ol>
<h5 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h5><ol>
<li>别名的设置：MyBatis帮我们实现了package scan的功能，使得我们不需写包名就能表示一个类。</li>
<li>MyBatis还实现了自动扫描配置文件的功能，所以不需要我们额外再告诉MyBatis项目中的mapper目录下放置的是DAO对应的SQL配置文件。</li>
<li>一般情况DAO实现类的配置也要写到xml文件中以告诉Spring容器，而这里MyBatis为我们自动实现DAO接口且MyBatis与Spring整合后可以自动将这个告知的步骤也实现。</li>
</ol>
<h4 id="MyBatis整合Spring编码"><a href="#MyBatis整合Spring编码" class="headerlink" title="MyBatis整合Spring编码"></a>MyBatis整合Spring编码</h4><ol>
<li>创建main-resources-spring目录，用来存放Spring相关配置。</li>
<li>新建spring-dao.xml存放DAO相关配置，从官网下载PDF格式官方文档，找到容器相关章节，复制Spring的xml配置文件头。</li>
<li>(1)配置数据库相关参数，写在properties文件(jdbc.properties)下。Spring配置支持classpath:前缀(指的是main-java和main-resources目录)和${url}(用来获取properties文件中的属性)。  </li>
</ol>
<p><strong>jdbc.properties文件的配置代码:</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver = com.mysql.jdbc.Driver  </span><br><span class="line">url = jdbc:mysql://127.0.0.1:3306/seckill?useUnicode=true&amp;characterEncoding=utf8  </span><br><span class="line">username = root  </span><br><span class="line">password = hgneer</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>在spring-dao.xml文件中配置数据库连接池(bean id = “dataSource”)，配置连接池属性(driverClass、jdbcUrl、user和password)和<br>连接池私有属性：maxPoolsize(30)、minPoolSize(10)、autoCommitOnClose(把连接放到池中前需要一些清理工作，设置为false，使得当关闭连接时不要commit)<br>、checkoutTimeout(获取连接超时时间，一般设置为1000，否则默认是0就会无限等待)和acquireRetryAttempts(获取连接失败重试次数，一般设置为2)。</li>
<li>配置MyBatis中最重要的一个API(bean id = “sqlSessionFatory”)：SqlSessionFactory对象用来创建会话工厂。  </li>
</ol>
<p><strong>有以下要点：</strong></p>
<ul>
<li>输入数据库连接池。</li>
<li>配置MyBatis全局配置文件为mybatis-config.xml。</li>
<li>配置扫描entity包(如果要省略多个包可以用分号隔开即可)，使用别名。</li>
<li>配置自动扫描sql配置文件：mapper需要的xml文件。</li>
</ul>
<ol start="6">
<li>配置扫描DAO接口包，使得动态实现DAO接口，注入到Spring容器中。  </li>
</ol>
<p><strong>有以下要点(class = “org.mybatis.spring.mapper.MapperScannerConfigurer”)：</strong></p>
<ul>
<li>注入sqlSessionFactory，注意使用sqlSessionFactoryBeanName，这样只有当我们使用时才加载，防止初始化滞后而导致的错误。</li>
<li>给出需要扫描的DAO接口包位置,以便于后面的MyBatis动态实现和自动注入。</li>
</ul>
<p><strong>总结:</strong></p>
<ol>
<li>MyBatis与Spring整合本质上是一些配置。</li>
<li>约定大于配置的启示，在特定包下新增特定类型文件，框架帮助自动识别，不需要额外配置。</li>
</ol>
<h4 id="DAO层单元测试编码与问题排查"><a href="#DAO层单元测试编码与问题排查" class="headerlink" title="DAO层单元测试编码与问题排查"></a>DAO层单元测试编码与问题排查</h4><ol>
<li>单元测试代码放在test-java目录。</li>
<li>因为DAO的实现类是MyBatis自动实现和注入到Spring容器的，所以在测试之前需要配置Spring与Junit整合。  </li>
</ol>
<ul>
<li>让Junit启动时加载SpringIOC容器，使用spring-runner提供了@RunWith(SpringJUnit4ClassRunner.class)。</li>
<li>告诉JUnit Spring DAO配置文件，使用@ContextConfiguration({“classpath:”})。</li>
<li>注入DAO实现类依赖，使用<br>@Resource(依赖注入注解)<br>private SeckillDao seckillDao;</li>
</ul>
<ol start="3">
<li>因为Java不会保存形参的记录，只以org0，org1这种形式表示，当方法只有一个参数时没事，但在DAO接口方法有多个参数时注意用MyBatis提供的@Param(“offset”)来标识，否则在SQL语句执行时找不到对应的参数。</li>
<li>阶段性测试，现在是测试数据绑定间是否存在问题，等Service写完再测逻辑层面的问题。</li>
<li>控制台信息可以复制到编辑版面进行可视化，更好地定位错误。 </li>
</ol>
<h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><h3 id="完成DAO层后的思考"><a href="#完成DAO层后的思考" class="headerlink" title="完成DAO层后的思考"></a>完成DAO层后的思考</h3><ul>
<li>DAO层没写一行逻辑代码，让代码与SQL分离，方便Review。</li>
<li>DAO层工作演变为：接口设计+SQL编写。</li>
<li>DAO层拼接等逻辑在Service层完成。</li>
</ul>
<h3 id="Service层设计和开发"><a href="#Service层设计和开发" class="headerlink" title="Service层设计和开发"></a>Service层设计和开发</h3><h4 id="Service接口设计"><a href="#Service接口设计" class="headerlink" title="Service接口设计"></a>Service接口设计</h4><ol>
<li>创建Service层所需要的包:service(存放Service接口和实现类)、exception(存放异常)和dto(存放表示数据的一些类型，关注Web层和Service层的数据传递)。</li>
<li>站在”使用者”角度去设计接口，设计接口时不要去关注实现。从三个方面来站在”使用者”角度设计接口：方法定义粒度要明确、参数要简练直接和返回类型要友好(有时返回的类型不适合用一个entity，就需要额外定义的dto类)(return 类型/异常)。</li>
<li>比如要有一个控制暴露秒杀地址的接口方法设计，这个方法在设计时根据需求要设计一个dto类作为返回类型。</li>
<li>dto设计使用md5作为加密措施。做不同的Constructor是为了方便我们进行不同初始化。</li>
<li>自己在exception目录下设计异常类，要分清楚运行期异常(运行期异常不用try-catch)和编译期异常，但是Spring的声明式事务只接收运行期异常回滚策略(所以我们创建的异常类继承RuntimeException，并生成message的两个构造方法)。</li>
<li>另外，一般情况，使用Spring，我们可以做一个通用的异常，然后让其它异常继承这个异常，当然，这个异常是继承自RuntimeException。</li>
</ol>
<h4 id="Service接口实现"><a href="#Service接口实现" class="headerlink" title="Service接口实现"></a>Service接口实现</h4><ol>
<li>创建service-impl作为实现类的包，实现类的命名是接口名+Impl。</li>
<li>在具体实现接口时，需要用到DAO类的配合，所以在实现类中声明需要的DAO类对象，但不用初始化，因为DAO类是MyBatis自动实现和注入Spring容器的。</li>
<li>另外，实现类编写时还需要引入日志对象(这里用的slf4j)。<br>(private Logger logger = LoggerFactory.getLogger(this.getClass()))。</li>
<li>系统的当前时间new一下就是：Date nowTime = new Date()，且nowTime.getTime()是表示毫秒个数的一个long类型的数字。</li>
<li>md5如何生成：加入一个混淆过程将用户特定字符串进行转换，所以先创建一个md5盐值字符串，用于混淆制作md5，然后创建一个方法，在这个方法里面调用Spring为我们提供的专门生成md5的工具类方法(DigestUtils.md5DigestAsHex(base.getBytes()))。</li>
<li>如果有重用的点，那抽象出一个方法出来就没毛病。</li>
<li>异常类的message有什么方法可以呈现到前端页面？</li>
<li>在实现执行方法时try-catch可能出现的编译期异常也都可以throw到我们之前创造的通用业务异常(运行期异常)，这样我们在出现未知异常时，Spring由于针对运行期异常，那么它就会为我们做rollback(很关键)，当然，这个catch要放最后，应该先catch子类异常。</li>
<li>用枚举来存储常量数据字典。</li>
<li>对象在使用默认的json进行转换时对枚举转换会出问题。</li>
</ol>
<h4 id="使用Spring托管Service依赖理论"><a href="#使用Spring托管Service依赖理论" class="headerlink" title="使用Spring托管Service依赖理论"></a>使用Spring托管Service依赖理论</h4><h5 id="Spring-IOC-依赖注入-理解"><a href="#Spring-IOC-依赖注入-理解" class="headerlink" title="Spring IOC(依赖注入)理解"></a>Spring IOC(依赖注入)理解</h5><ol>
<li>Spring IOC提供一个对象工厂帮我们创建Service的实现并完成Service当中的依赖管理，最终给我们一个一致的访问接口。<br>也就使得我们不用管创建过程和依赖管理，直接使用一致接口获取实例。  </li>
<li>业务对象依赖图　　<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5.png" alt=""></li>
<li>为什么用IOC?</li>
</ol>
<ul>
<li>对象创建统一托管。</li>
<li>规范的生命周期管理(让我们在特定生命周期增删逻辑更方便)。</li>
<li>灵活的依赖注入(可以编程，可以注解，可以第三方)。</li>
<li>一致地获取对象实例(这些对象实例还都是默认单例的)。</li>
</ul>
<ol start="4">
<li>Spring IOC注入方式和场景</li>
</ol>
<ul>
<li>Java配置类：需要代码控制对象创建逻辑的场景，如自定义修改类库(不常用)。</li>
<li>注解：项目自身开发使用的类，可直接在代码中使用注解，如@Service、@Controller等。</li>
<li>xml:Bean实现类来自第三方类库，如DataSource；需要命名的空间配置如context、aop、mvc等。</li>
</ul>
<h4 id="本项目IOC使用"><a href="#本项目IOC使用" class="headerlink" title="本项目IOC使用"></a>本项目IOC使用</h4><ol>
<li>XML配置</li>
<li>package-scan(DAO)</li>
<li>Annotation注解(Service)</li>
</ol>
<h4 id="使用Spring托管Service依赖配置"><a href="#使用Spring托管Service依赖配置" class="headerlink" title="使用Spring托管Service依赖配置"></a>使用Spring托管Service依赖配置</h4><ol>
<li>在resources-spring目录下创建spring-service.xml文件，来配置Service，<br>目的让Spring扫描service包下所有使用注解的类型并注入到容器(&lt;context:component-scan base-package=”org.seckill.service”/&gt;)。</li>
<li>另外，开始对自己开发的Service来完成基于注解的配置。</li>
<li>Spring提供的几种注解：@Component(组件统称)、@Service、@Dao和@Controller。</li>
<li>MyBatis自动实现了DAO类对象在Service类使用时，需要使用@Autowired注解(或者@Inject、@Resource)来注入Service依赖。</li>
</ol>
<h4 id="Spring声明式事务"><a href="#Spring声明式事务" class="headerlink" title="Spring声明式事务"></a>Spring声明式事务</h4><ol>
<li>什么是声明式事务？<br>正常一个事务过程包括：开启事务-修改SQL1-修改SQL2-修改SQL3-等等-提交/回滚事务。<br>那使用声明式事务后，事务的开启和结尾阶段都交由第三方框架完成，我们不需要关心，只关心SQL操作，解脱了我们的事务操作。</li>
<li>Spring声明式事务的使用方式：</li>
</ol>
<ul>
<li>ProxyFactoryBean + XML : 早期使用方式(2.0)。</li>
<li>tx:advice + aop命名空间 ： 一次配置永久生效。</li>
<li>注解@Transactional : 注解控制(推荐，这样会在方法中加入注解，便于团队间的交流。)。</li>
</ul>
<ol start="3">
<li>事务方法嵌套</li>
</ol>
<ul>
<li>这是声明式事务独有的概念，和MySQL无关</li>
<li>Spring默认的传播行为(当有多个方法调用时是创建一个新事务还是加入到已有的事务)是propagation_required(它是如果事务有，加入到原有事务当中)</li>
</ul>
<ol start="4">
<li>什么时候回滚事务?</li>
</ol>
<ul>
<li>当方法抛出运行期异常(RuntimeException)，很重要</li>
<li>所以要小心谨慎的try-catch</li>
</ul>
<h5 id="配置并使用Spring声明式事务"><a href="#配置并使用Spring声明式事务" class="headerlink" title="配置并使用Spring声明式事务"></a>配置并使用Spring声明式事务</h5><p>在spring-service.xml文件中配置事务声明管理器：MyBatis采用的是JDBC的事务管理器，所以引入spring默认的transactionManager。</p>
<ol>
<li>配置注入数据库连接池(这里有个小问题，在dataSource命名空间下找不到ref=”dataSource”,这是因为我们配置的dataSource在spring-dao.xml<br>文件中，这里找不到没关系，到时候运行时两个xml文件都给到Spring，它会自动帮我们找到)。</li>
<li>配置基于注解的声明式事务(tx:annotation-driven transaction-manager=”transactionManager”)，这样就使得可以默认使用注解管理事务行为。  </li>
</ol>
<p><strong>使用注解控制事务方法的优点：</strong></p>
<ul>
<li>开发团队达成一致约定，养成明确标注事务方法的编程风格。</li>
<li>保证事务方法的执行时间尽可能短，将网络操作如RPC/HTTP请求等耗时操作剥离到事务方法外部。</li>
<li>不是所有的方法都需要事务，如果只有一条修改操作或一般的只读操作(因为只读操作不会对数据库进行修改，不会用到回滚。)是不需要事务控制的。</li>
</ul>
<h4 id="集成测试Service逻辑"><a href="#集成测试Service逻辑" class="headerlink" title="集成测试Service逻辑"></a>集成测试Service逻辑</h4><ol>
<li>主要针对业务实现类。</li>
<li>首先还是需要配置Spring-Junit依赖：<br>@Runwith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration({<br>“classpath:spring/spring-dao.xml”,<br>“classpath:spring/spring-service.xml”})</li>
<li>用Spring注解@Autowired方式注入我们的测试对象实例。</li>
<li>配置日志管理logback:<br>在resources目录下创建logback.xml文件，将官网的配置头文件(默认的直接打印到控制台)和xml头拷贝进去</li>
<li>logger.warn可用于警告。</li>
<li>测试代码要能覆盖完整逻辑且注意可重复执行。</li>
</ol>
<h2 id="Web层设计与实现"><a href="#Web层设计与实现" class="headerlink" title="Web层设计与实现"></a>Web层设计与实现</h2><p>内容概述  </p>
<ul>
<li>前端交互设计</li>
<li>Restful接口设计</li>
<li>Spring MVC</li>
<li>Bootstrap + JQuery</li>
</ul>
<h3 id="前端交互流程设计"><a href="#前端交互流程设计" class="headerlink" title="前端交互流程设计"></a>前端交互流程设计</h3><p>标准：根据用户需求设计前端交互流程<br>涉及的人员：产品、前端和后端  </p>
<h4 id="前端页面流程"><a href="#前端页面流程" class="headerlink" title="前端页面流程"></a>前端页面流程</h4><p><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/6.png" alt=""></p>
<h4 id="详情页面流程"><a href="#详情页面流程" class="headerlink" title="详情页面流程"></a>详情页面流程</h4><p><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/7.png" alt=""></p>
<h3 id="学习Restful接口设计"><a href="#学习Restful接口设计" class="headerlink" title="学习Restful接口设计"></a>学习Restful接口设计</h3><h4 id="什么是Restful"><a href="#什么是Restful" class="headerlink" title="什么是Restful"></a>什么是Restful</h4><ul>
<li>兴起于Rails</li>
<li>一种优雅的URI表述方式</li>
<li>关于状态转移(动词)和资源的状态(名词表示)</li>
</ul>
<h4 id="Restful规范"><a href="#Restful规范" class="headerlink" title="Restful规范"></a>Restful规范</h4><ul>
<li>GET -&gt; 查询操作</li>
<li>POST -&gt; 添加/修改操作(非幂等)</li>
<li>PUT -&gt; 修改操作(幂等[一个操作执行多次与一次的结果一样且不会对系统造成崩坏性的影响])</li>
<li>DELETE -&gt; 删除操作</li>
</ul>
<h4 id="Restful的URL设计"><a href="#Restful的URL设计" class="headerlink" title="Restful的URL设计"></a>Restful的URL设计</h4><p>/模块/资源/{标示}/集合1/…<br>如：/user/{uid}/frends -&gt; 好友列表&nbsp;&nbsp;&nbsp;&nbsp;/user/{uid}/followers -&gt; 关注者列表</p>
<h4 id="秒杀API的URL设计"><a href="#秒杀API的URL设计" class="headerlink" title="秒杀API的URL设计"></a>秒杀API的URL设计</h4><ul>
<li>GET /seckill/list -&gt; 秒杀列表</li>
<li>GET /seckill/{id}/detail -&gt; 详情页</li>
<li>GET /seckill/time/now -&gt; 系统时间</li>
<li>POST /seckill/{id}/exposer -&gt; 暴露秒杀</li>
<li>POST /seckill/{id}/{md5}/execution -&gt; 执行秒杀</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用Restful接口可以方便伙伴间的交流，养成良好的设计思路和风格。</p>
<h3 id="Spring-MVC整合Spring"><a href="#Spring-MVC整合Spring" class="headerlink" title="Spring MVC整合Spring"></a>Spring MVC整合Spring</h3><h4 id="使用Spring-MVC框架理论"><a href="#使用Spring-MVC框架理论" class="headerlink" title="使用Spring MVC框架理论"></a>使用Spring MVC框架理论</h4><p>概述：我们始终围绕Handler开发<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/8.png" alt=""><br>页面View的格式可以是Json、JSP甚至PDF。</p>
<h4 id="Spring-MVC运行流程"><a href="#Spring-MVC运行流程" class="headerlink" title="Spring MVC运行流程"></a>Spring MVC运行流程</h4><p><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/9.png" alt=""></p>
<ul>
<li>DispatcherServlet : 中央控制器的Servlet，会拦截用户所有的请求。</li>
<li>DefaultAnnotationHandlerMapping : 用来映射URL，明确我们哪些URL对应哪些Handler。</li>
<li>DefaultAnnotationHandlerAdapter : 用来做一个Handler适配，衔接我们编写的Controller(如果用到Intercept拦截器，它也会将拦截器绑定在我们的流程当中)。</li>
<li>上述步骤产生的ModelAndView交付到DispatchServlet后，会根据我们应用的View格式匹配相应的ViewResolver，然后解析后将View与Model相结合返回给用户。在使用jsp我们可以设置返回一个字符串，这个字符串对应一个jsp页面，而使用json做view的话只要把图中jsp改成json即可。</li>
</ul>
<h4 id="HTTP请求地址映射原理"><a href="#HTTP请求地址映射原理" class="headerlink" title="HTTP请求地址映射原理"></a>HTTP请求地址映射原理</h4><p><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/10.png" alt=""></p>
<h5 id="注解映射技巧"><a href="#注解映射技巧" class="headerlink" title="注解映射技巧"></a>注解映射技巧</h5><p>@RequestMapping注解：<br>(1) 支持标准的URL<br>(2) Ant风格URL 如/user/*/creation<br>(3) 带{xxx}占位符的URL 如/user/{userId}  </p>
<h4 id="Spring-MVC请求方法细节处理"><a href="#Spring-MVC请求方法细节处理" class="headerlink" title="Spring MVC请求方法细节处理"></a>Spring MVC请求方法细节处理</h4><ol>
<li>请求参数绑定</li>
<li>请求方式限制(写的Handler方法只允许GET或POST或PUT等提交，如何限制)</li>
<li>重定向和请求转发</li>
<li>数据模型赋值(将什么样的数据传递给jsp或json)</li>
</ol>
<p>一个可以展现上诉各个细节处理的例子:<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/11.png" alt=""></p>
<ol start="5">
<li>返回json数据<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/12.png" alt=""></li>
<li>cookie访问<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13.png" alt=""></li>
</ol>
<h4 id="整合配置Spring-MVC框架"><a href="#整合配置Spring-MVC框架" class="headerlink" title="整合配置Spring MVC框架"></a>整合配置Spring MVC框架</h4><p>在WEB-INF目录下的web.xml文件配置Spring MVC框架：  </p>
<ol>
<li>配置DispatchServlet(servlet-name和servlet-class)。</li>
<li>配置Spring MVC需要加载的配置文件：spring-dao.xml、spring-service.xml和spring-web.xml，且配置的加载顺序是：Mybatis-Spring-Spring MVC。</li>
<li>做Servlet的Mapping，直接用/表示默认匹配所有请求，让所有请求都转到DispatchServlet当中。</li>
<li>新建resources-spring-spring-web.xml文件进行配置：</li>
</ol>
<ul>
<li>开启Spring MVC注解模式(<a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>)，它实质上是一个简化配置，完成了以下功能：<br>(1) 自动注册DefaultAnnotationHandlerMapping和DefaultMethodHandlerAdapter。<br>(2) 提供一系列功能：数据绑定、数字和日期的format(@NumberFormat、@DateTimeFormat)、xml和json的读写支持。</li>
<li>因为配置的servlet-mapping的映射路径是”/“，所以在这里我们需要有一个静态资源默认servlet配置(mvc:default-servlet-handler)，它也有两个作用：<br>(1) 允许使用”/“做整体映射。<br>(2) 加入对静态资源的处理：js，gif，png等。</li>
<li>配置jsp显示对应的ViewResolver(InterResourceViewResolver、viewClass、prefix和suffix)。</li>
<li>还可以配置json，但是第一步配置其实已经默认开启了。</li>
<li>配置扫描web相关的包(和之前DAO层与Service层类似要进行的配置)。</li>
<li>需要拦截器就在额外进行相应配置(从官网获取)。</li>
</ul>
<h3 id="实现秒杀相关的Restful接口"><a href="#实现秒杀相关的Restful接口" class="headerlink" title="实现秒杀相关的Restful接口"></a>实现秒杀相关的Restful接口</h3><ol>
<li>新建java-web目录用于存放Controller类，用这些Controller类来实现Restful接口。</li>
<li>在Controller类上面加上几个注解：@Controller和@RequestMapping(“/seckill”)(用来作为URL映射地址的/模块)。</li>
<li>具体方法实现层，list.jsp + model = ModelAndView，Model对象用来存放(使用model.Attribute()方法)渲染所需的数据。\<br>方法的返回值结合之前对VieResolver的配置可以直接返回一个字符串来对应一个jsp页面。另外，方法上层需要使用RequestMapping\<br>进行二级的URL映射和限制对应HTTP请求方式。</li>
<li>当然，Controller方法层次上的实现要对Service层进行调用，所以也需使用注解的方式(@Autowired和@Resources等)将Service对象依赖注入到Controller类中。</li>
<li>此外，类里面也需配置日志对象对各种信息进行管理。</li>
<li>RequestMapping中使用占位符时需要在方法的参数设置上加上@PathVariable(“seckillId”)这种类似代码。</li>
<li>用redirect:/seckill/list或forward:/seckill/list可以用来重定向和请求转发。</li>
<li>Contorller控制层也就是接收某些参数后，结合我们设计好的dto类型为我们做跳转控制。</li>
<li>AJax的Restful方法接口实现时的返回类型一般设置为json类型，然后在方法前方除了需要进行\<br>@RequestMapping注解,还需要加上@ResponseBody注解来告诉Spring MVC这个方法的返回类型\<br>算作一个json，此外，最好在@RequestMapping下额外加上参数produces = {“application/json;charset\<br>=UTF-8”}\来告诉浏览器我们的contentType来防止json或者中文乱码问题，养成良好的习惯。</li>
<li>AJax所需要的json类型需要自己创建一个dto类来进行封装，这个类一般设置为泛型，使得所有的AJax请求返回类型都可以用此类设置。</li>
<li>方法的参数从Cookie中获取时需要加上@CookieValue(value = “killPhone”,required = false)的设置。\<br>另外，这里设置的required = false是说当cookie中获取不到killPhone变量时不要让Spring MVC\<br>来报错，而是赋予我们程序来处理这样一个逻辑的机会。</li>
<li>系统当前日期直接使用Date now = new Data()来new一个对象即可。</li>
</ol>
<h3 id="基于bootstrap开发页面结构"><a href="#基于bootstrap开发页面结构" class="headerlink" title="基于bootstrap开发页面结构"></a>基于bootstrap开发页面结构</h3><ol>
<li>采用CSS直接埋点的方式为我们提供了很多方便的样式。</li>
<li>我们直接通过拷贝HTML模板方式使用bootstrap。</li>
<li>在WEB-INF目录下新建jsp目录用来存放jsp文件，jsp文件头用拷贝过来的HTML模板替换，之后修改。</li>
<li>使用的这个模板帮我们简单做了一些浏览器的适配，引入了JQuery库，但是模板上使用的bootstrap是一个压缩版本，<br>我们找一个好的CDN版本进行替换，另外，CDN版本中的主题代码一般不使用。</li>
<li>需要注意使用CDN版本bootstrap后，我们在调试时需要全程联网。</li>
<li>jsp通用的头文件代码可以独立出来放到jsp-common目录下作为head.jsp，然后在具体jsp\<br>文件中用静态引入(&lt;%@include file = “common/head.jsp”%&gt;)的方式引入。(静态引入是直接\<br>将被引用文件中jsp代码插入引用文件中，只开一个Servlet；动态引入则是开多个Servlet，是\<br>将被引用jsp文件运行后的结果html<br>代码合并到引用文件结果html代码中。)</li>
<li>使用bootstrap建议将所有显示内容放在几个div骨架下：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"panel panel -default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"panel-heading text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"panel-body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>具体的显示内容div放在panel-body下，至于需要使用的列表各种组件样式就查询bootstrap官网使用即可。<br>table的创建：table-thead-tr-th做表头，table-tbody-tr-td做表行。表行里的内容一般用core标签来迭\<br>代从bean中获取(c:forEach var = “sk” items = “${list}”)。</p>
<ol start="8">
<li>若需要使用的jstl这样的标签库，引入代码也是可以独立成为一个tag.jsp文件用于静态引入。<br>需要的两个标签是：core和fmt。</li>
<li>用fmt格式化时间显示举例：&lt;fmt:formatDate value = “${sk.startTime}” pattern = “yyyy-MM-dd HH:mm:ss”&gt;。 </li>
<li>可以使用bootstrap做一个按钮式的超链接样式。</li>
</ol>
<h3 id="交互逻辑编程"><a href="#交互逻辑编程" class="headerlink" title="交互逻辑编程"></a>交互逻辑编程</h3><h4 id="cookie登录交互"><a href="#cookie登录交互" class="headerlink" title="cookie登录交互"></a>cookie登录交互</h4><ol>
<li>bootstrap的Modal插件可以为我们做一个弹出层，bootstrap的modal的CSS规范是：\<br>modal-content + modal-body + modal-footer。</li>
<li>埋点id=”killPhoneModal”可以方便我们使用id来查询到对应的整个div组件。</li>
<li>input可以给用户填写信息，span标签则可用于显示出错信息。</li>
<li>JQuery的Cookie操作插件和countDown插件可以使用bootstrap为我们提供好的一个CDN\<br>(<a href="http://www.bootcdn.cn)来直接获取。" target="_blank" rel="noopener">http://www.bootcdn.cn)来直接获取。</a></li>
<li>使用CDN是Web项目一个很好的加速点。</li>
<li>新建webapp-resources-script目录，在此目录下编写js文件完成交互逻辑编程。</li>
<li>写好的js文件可在jsp文件中用&lt;script src = “/resources/script/seckill.js” type = “text/javascript”&gt;&lt;/script&gt;来引入，注意此处有个小坑，<br>&lt;/script&gt;不能用&lt;/&gt;来替代，否则javascript代码会不能执行。</li>
<li>注意写javascript时要做到模块化，java的模块化可以通过分包来实现，javascript中没\<br>有package的概念，但是我们可以用json对象来封装多个对象来使得之后调用时产生一个分包\<br>模拟效果，让我们规范我们的程序编写风格。另外，正式写代码前一定要先规划好我们的交互流程。</li>
<li>一开始的初始化放在init中，在jsp文件中使用&lt;script type = “text/javascript”&gt;\<br>$(function())可以调用javascript方法并且使用EL表达式传入bean中的参数到javascript对象方法。</li>
<li>由于已经使用cookie插件，在javascript文件中我们可以直接使用$.cookie(‘killPhone’)的方式获取cookie数据。</li>
<li>javascript中访问jsp设置的参数方式：var startTime = parames[‘startTime’]。</li>
<li>验证操作最好放在javascript代码最上层，利于复用。</li>
<li>在javascript中可以通过#号用选择器的方式选中jsp中的一段组件，如$(‘#killPhoneModal’)。</li>
<li>Modal类型的控制输出(点击事件、键盘事件等)可以调用它自身的一个方法来实现。</li>
<li>控制显示出弹出层后，我们应该为弹出层的组件做数据绑定。</li>
<li>cookie为什么不给全路径，一般只绑到/模块？</li>
<li>往页面插更新内容时最好先隐藏一下再给个限制事件来显示出来，让界面显示对用户更加\<br>友好，防止他们看到中间等待页面。$(‘killPhoneMessage’).hide().html(‘<label class="label label-danger">手机号错误！</label>‘).show(300);</li>
</ol>
<h4 id="计时交互设计"><a href="#计时交互设计" class="headerlink" title="计时交互设计"></a>计时交互设计</h4><ol start="18">
<li>之前的时间对象实质上是放在json里面，我们用ajax的get操作可以拿到。</li>
<li>需要注意的是我们不希望js代码中直接出现与我们后端交互拿数据的代码，为了缓解\<br>这个问题，我们应该将想要请求数据的URL封装到js中json的URL对象里(做成一个function)。</li>
<li>javascript中也可以用console输出错误信息方便我们进行调试。</li>
<li>将计时模块抽取到一个function： countdown : function (seckillId,nowTime,startTime,endTime)。</li>
<li>计时加一秒，防止用户时间可能出现的偏差。</li>
<li>倒计时完成时需要有一个回调事件的操作(使用on)。</li>
</ol>
<h4 id="秒杀交互设计"><a href="#秒杀交互设计" class="headerlink" title="秒杀交互设计"></a>秒杀交互设计</h4><ol start="24">
<li>绑定链接时最好用one而非click，因为click会一直绑定，one则只绑定一次点击事件。</li>
<li>所有节点显示操作之前最好都先隐藏一下，之后用逻辑来控制。</li>
<li>代码一点一点的重构，不要妄想一步登天。</li>
</ol>
<h3 id="Web层总结"><a href="#Web层总结" class="headerlink" title="Web层总结"></a>Web层总结</h3><h4 id="前端交互设计过程"><a href="#前端交互设计过程" class="headerlink" title="前端交互设计过程"></a>前端交互设计过程</h4><p>编码前选择先想清楚前端的交互过程。</p>
<h4 id="Restful接口设计"><a href="#Restful接口设计" class="headerlink" title="Restful接口设计"></a>Restful接口设计</h4><p>URL设计遵循Restful规范，在Controller中具体实现Restful接口。</p>
<h4 id="Spring-MVC使用技巧"><a href="#Spring-MVC使用技巧" class="headerlink" title="Spring MVC使用技巧"></a>Spring MVC使用技巧</h4><ul>
<li>Spring MVC配置和运行流程</li>
<li>DTO传递数据</li>
<li>注解映射驱动<h4 id="BootStrap和JavaScript使用"><a href="#BootStrap和JavaScript使用" class="headerlink" title="BootStrap和JavaScript使用"></a>BootStrap和JavaScript使用</h4></li>
<li>BootStrap样式</li>
<li>JavaScript模块化</li>
<li>JQuery和Plugin使用</li>
</ul>
<h2 id="高并发优化"><a href="#高并发优化" class="headerlink" title="高并发优化"></a>高并发优化</h2><ol>
<li>高并发发生在哪里？<br>首先可以分析一下业务流程：<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/14.png" alt=""><br>红色部分可能需要高并发，绿色部分则无关紧要。</li>
<li>为什么要单独获取系统时间？<br>为了给我们的高并发优化做铺垫？<br>因为这里考虑到一个场景：用户在秒杀未开始时肯定会频繁刷新页面，而我们为了提高系统的并发\<br>性，一般会把我们的页面静态化并且将css，js等静态资源放到CDN服务器上，也就是说要访问detail\<br>这样的页面，是不需要访问我们的系统，而是直接访问CDN服务器，那这个时候也就拿不到我们的系\<br>统时间所以我们要单独做一个请求来获取当前系统服务器的系统时间。</li>
<li>CDN的理解</li>
</ol>
<ul>
<li>CDN(内容分发网络)是加速用户获取数据的系统。</li>
<li>部署在离用户最近的网络节点上。</li>
<li>命中CDN不需要访问后端服务器。</li>
<li>CDN互联网公司一般会自己搭建或租用。</li>
</ul>
<ol start="4">
<li>获取系统时间不用优化<br>因为Java访问一次内存大约10ns，而访问系统时间本质上就是new了一个日期对象然后把这个对象返\<br>回给用户，那么这样一个操作如果不考虑GC的影响，一秒钟就可以做一亿次，所以不用优化。</li>
<li>秒杀地址接口分析</li>
</ol>
<ul>
<li>无法使用CDN缓存，因为CDN缓存的都是不变的数据，这个地址是在变的。</li>
<li>适合放在服务器端缓存：redis等，后端的缓存是可以由我们的业务逻辑来控制。</li>
<li>一致性维护成本低，可以在redis改，也可以在mysql改，也可以等超时后再改。  </li>
</ul>
<p>秒杀地址接口优化<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/15.png" alt="">  </p>
<ol start="6">
<li>秒杀操作的优化分析</li>
</ol>
<ul>
<li>无法使用CDN缓存。</li>
<li>后端缓存困难：库存问题，无法进行数据库的事务处理。</li>
<li>一行数据竞争：热点商品。</li>
</ul>
<ol start="7">
<li>其他方案分析<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/16.png" alt=""><br>这些分布式组件组合在一起，并发量接受能力很强。<br>但是痛点就在于成本：<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/17.png" alt=""><br>为什么不用MySQL解决？<br>认为MySQL低效，然而一条update压力测试可以抗住约4w的QPS，也就说同一个产品一秒钟可以卖4w次。\<br>那是什么使得MySQL低效了？<br>可以先看下Java控制事务行为的分析：<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/18.png" alt=""><br>延迟分析：<br>本地机房的一个网络延迟就在0.5ms-2ms间了，如果加上JVM-GC操作时间，整个的QPS最大就在20左右了。<br>异地机房(Tomcat和MySQL分开)时的QPS就更低了。<br>瓶颈分析：<br>Java客户端执行update放到服务器就有网络延迟，此外在java服务端与MySQL进行事务操作时又会有GC的操作。<br>那把网络延迟和Java与MySQL通信的GC等等待时间加到整个事务时间内，这个时间就长了。<br>优化分析：<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/19.png" alt=""></li>
</ol>
<p><strong>如何判断一个Update更新库存成功？</strong></p>
<ul>
<li>Update自身没报错</li>
<li>客户端确认Update影响记录数<br>那得到优化思路：把客户端逻辑放到MySQL服务端，避免网络延迟和GC影响。  </li>
</ul>
<p><strong>如何放到MySQL服务端？</strong></p>
<ul>
<li>定制SQL方案：update/<em> + [auto_commit] </em>/，需要修改MySQL源码。</li>
<li>使用存储过程：让整个事务在MySQL端完成。(存储过程本身设计出来就是想让一组SQL组成\<br>一个事务，然后在服务端完成，避免用客户端去完成事务造成的一个性能的干扰，而一般Spring\<br>声明式事务和手动控制事务都是客户端控制事务，这样的控制在行级锁不多的时候完全OK，但是秒\<br>杀类的同一行竞争太激烈，这个时候就需要存储过程来发挥作用。)</li>
</ul>
<p><strong>优化总结</strong></p>
<ul>
<li>前端控制：暴露接口，按钮防重复。</li>
<li>动静态数据分离：CDN缓存，后端缓存。</li>
<li>事务竞争优化：减少事务行级锁持有时间。</li>
</ul>
<h3 id="redis后端缓存优化编码"><a href="#redis后端缓存优化编码" class="headerlink" title="redis后端缓存优化编码"></a>redis后端缓存优化编码</h3><p>有逻辑变化控制且频繁需要访问数据库的一些资源可以交由redis进行后端缓存。<br>我们现在的重点是用Java去访问我们本地已经搭建好的Redis来做缓存。  </p>
<ol>
<li>打开pom.xml文件，引入Java访问redis的客户端(我们用jedis)，可以从官网查看各种语言\<br>推荐使用的对应客户端。</li>
<li>在pom.xml文件中引入redis依赖。</li>
<li>我们来为暴露地址接口和秒杀执行接口做一个redis缓存。</li>
<li>常用的缓存编码设计如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get from cache</span><br><span class="line">  if null </span><br><span class="line">    get db</span><br><span class="line">  else </span><br><span class="line">    put cache</span><br><span class="line">logic</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样写逻辑上没问题，但是注意不要将这样的缓存控制直接写到业务逻辑当中(Service)。<br>而是应该将这样的缓存控制写到DAO层，它才是放数据存储或缓存的一个层次。  </p>
<ol start="5">
<li>新建dao-cache包，在这个包内创建RedisDao，对这个类我们就直接在里面实现Redis的缓存控制，\<br>至少要设置JedisPool、构造方法、getSeckill和putSeckill。  </li>
<li>数据库和jedis这样的close记得要的final里面执行。  </li>
<li>构造Redis键值对时，需要注意redis和jedis都没有实现内部序列化操作，所以我们在赋值\<br>时要注意序列化的一个操作。 一般从Redis是获取一个二进制byte数组，到Java里我们应该反\<br>序列化成为一个对象，即：get -&gt; byte[] -&gt; 反序列化(字节数组到对象) -&gt; Object(Seckill)。\<br>此时注意高并发里面有一个很容易忽视的问题就是序列化的问题。一般序列化我们只需在Seckill.java\<br>实现一个Serializable，默认使用JDK自己的序列化机制。但是考虑高并发时我们就应该在序列化上再多\<br>做文章。Github有一个工程名为JVM-Serialization做了各种序列化工具性能的比对。我们决定采用性能高\<br>的序列化工具自定义序列化操作。  </li>
<li>我们选择使用protostuff序列化工具，首先要在pom.xml文件中加上protostuff-core和protostuff-runtime两个依赖，之后我们一句protostuff的标准进行反序列化(告诉schema和字节数组，用ProtostuffIOUtil)。  </li>
<li>put要做的工作就是将对象转成字节数组。  </li>
<li>另外，注意养成一个好习惯，写完一个DAO后要写一个单元测试进行测试。  </li>
<li>测试Redis的DAO时我们就注意要先在spring-dao.xml文件中自己注入RedisDao，我们使用的是构造方法注入。  </li>
<li>之后在Service注入写好的RedisDao，让拿暴露地址时先访问Redis，没有再访问MySQL。  </li>
<li>另外，这里的一致性建立在超时的基础上维护。</li>
</ol>
<h3 id="并发优化"><a href="#并发优化" class="headerlink" title="并发优化"></a>并发优化</h3><p>简单优化可以从行级锁持有时间入手，秒杀事务执行的过程之前是update-insert-commit/rollback，\<br>而行级锁在update时就开启了，我们可以改变这个事务过程为insert-update-commit/rollback来降低行\<br>级锁持有时间，同时也让客户端与MySQL间的网络延迟和GC处理时间降低了一倍，达到优化的目的。</p>
<h3 id="深度优化"><a href="#深度优化" class="headerlink" title="深度优化"></a>深度优化</h3><p>使用存储过程将事务MySQL放在MySQL端执行，进一步降低网络延迟的影响。\<br>要提高并发量，需要想尽办法降低行级锁到commit的持续时间。</p>
<ol>
<li>在sql目录下新建seckill.sql文件，在里面写秒杀执行的存储过程。</li>
<li>在存储过程中默认和MySQL终端一样也是通过分号(;)来作为分行符，我们首先使用DELIMITER $$\<br>使得存储过程中用$$表示分行符。</li>
<li><p>定义存储过程(in 输入参数 out 输出参数 row_count() 返回上一条修改类型(insert、delete和update)sql\<br>的影响行数)：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CREATE PRODUCER `seckill`.`execute_seckill`  </span><br><span class="line">  (in v_seckill_id bitint,in v_phone bigint,  </span><br><span class="line">  in v_kill_time timestamp,out r_result int)  </span><br><span class="line">  BEGIN</span><br><span class="line">    DECLARE insert_count int DEFAULT 0;</span><br><span class="line">    START TRANSACTION;</span><br><span class="line">    -- success_killed是秒杀明细表</span><br><span class="line">    insert ignore into success_killed</span><br><span class="line">      (seckill_id,user_phone,create_time)</span><br><span class="line">      values (v_seckill_id,v_phone,v_kill_time);</span><br><span class="line">    select row_count() into insert_count;</span><br><span class="line">    -- row_count(): 0 执行生效但未修改数据； &gt;0 表示修改数据的行数；&lt;0 sql错误/未执行sql</span><br><span class="line">    IF (insert_count = 0) THEN</span><br><span class="line">      ROLLBACK;</span><br><span class="line">      -- 之前的数据字典定义的返回结果：-2为内部错误 -1为重复秒杀 0为秒杀结束。</span><br><span class="line">      set r_result = -1;</span><br><span class="line">    ELSEIF (insert_count &lt; 0) THEN</span><br><span class="line">      ROLLBACK;</span><br><span class="line">      set r_result = -2;</span><br><span class="line">    ELSE</span><br><span class="line">      update seckill</span><br><span class="line">      set number = number - 1</span><br><span class="line">      where seckill_id = v_seckill_id</span><br><span class="line">        and end_time &gt; v_kill_time</span><br><span class="line">        and start_time &lt; v_kill_time</span><br><span class="line">        and number &gt; 0;</span><br><span class="line">      select row_count() into insert_count;</span><br><span class="line">      IF (insert_count = 0) THEN</span><br><span class="line">        ROLLBACK;</span><br><span class="line">        set r_result = 0;</span><br><span class="line">      -- 这个时候的insert_count &lt; 0可能是因为sql执行出错，也可能是因为等待行级锁超时了。</span><br><span class="line">      ELSEIF (insert_count &lt; 0) THEN</span><br><span class="line">        ROLLBACK;</span><br><span class="line">        set r_result = -2;</span><br><span class="line">      ELSE</span><br><span class="line">        COMMIT;</span><br><span class="line">        set r_result = 1;</span><br><span class="line">      END IF</span><br><span class="line">    END IF;</span><br><span class="line">  END;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后我们可以在MySQL终端通过以下代码调用存储过程：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 把分行符转换回;</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 终端上赋值变量需要加@</span><br><span class="line">set @r_result = -3;</span><br><span class="line">-- 执行存储过程</span><br><span class="line">call execute_seckill(1003,13502178891,now(),@r_result);</span><br><span class="line">-- 获取结果</span><br><span class="line">select @r_result;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储过程优化的是事务行级锁持有的时间，但不要过度依赖存储过程，存储过程在一般的\<br>互联网公司并不是重点，只是银行用的多，且在我们的秒杀系统并发优化的需要，只有遇到简\<br>单的逻辑而且需要高并发时才去应用存储过程。</p>
</li>
<li>我们的秒杀系统在用了存储过程之后经过测试一个秒杀单可以有6000的QPS。</li>
<li>那之前通过Spring声明式事务定义的秒杀操作要如何修改以应用存储过程？<br>定义一个新的接口，这个接口是用存储过程来执行秒杀，这个接口的具体实现当然也就与Java客户端如何调用存储过程息息相关。</li>
<li>需要在seckillDao定义一个调用存储过程的逻辑，这个接口方法返回值类型可以设置为void，参数则需要传一个Map&lt;String,Object&gt; paramMap，接口实现当然还是在xml中配置让mybatis调用存储过程。</li>
<li>xml中调用的话注意使用statementType = “CALLABLE”，之后使用：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call execute_seckill(</span><br><span class="line">  #&#123;seckillId,jdbcType=BIGINT,mode=IN&#125;,</span><br><span class="line">  #&#123;phone,jdbcType=BIGINT,mode=IN&#125;,</span><br><span class="line">  #&#123;killTime,jdbcType=TIMESTAMP,mode=IN&#125;,</span><br><span class="line">  #&#123;result,jdbcType=INTEGER,mode=OUT&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>之后在业务逻辑Service中调用Dao调用存储过程方法，当然在此之前需要我们自己创建一个\<br>Map作为该方法的参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();  </span><br><span class="line">map.put (<span class="string">"seckillId"</span>,seckillId);  </span><br><span class="line">map.put(<span class="string">"phone"</span>,userPhone);  </span><br><span class="line">map.put(<span class="string">"killTime"</span>,killTime);  </span><br><span class="line">map.put(<span class="string">"result"</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>注意： 为什么我们需要设置一个Map作为该方法的参数，是因为我们结果result通过Map也\<br>能放到参数里面，这样当我们的存储过程执行完成之后，result被赋值。当然，这个过程也\<br>是可能发生异常的，注意try-catch。另外，要想通过MapUtils.getInteger(map,”result”,-2)\<br>来获取result，需要在pom.xml引入依赖commons-collections。Cotroller也是需要调用存储\<br>过程来执行秒杀。  </p>
<ol start="10">
<li>记得阶段性测试。</li>
</ol>
<h3 id="系统部署架构"><a href="#系统部署架构" class="headerlink" title="系统部署架构"></a>系统部署架构</h3><p>系统可能用到哪些服务？</p>
<ul>
<li>CDN(BootStrap,JQuery的依赖)</li>
<li>WebServer：Nginx + Tomcat(HTTP服务器和应用服务器)</li>
<li>Redis(服务器端的缓存，热点数据的快速存储)</li>
<li>MySQL(事务)</li>
</ul>
<p>系统部署架构图<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%9F%BA%E4%BA%8ESSM%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/20.png" alt=""><br>分库分表一般按照关键Id进行，把流量压力分散开来，而分库分表可以自己取模或者借用专门\的框架来完成。  </p>
<p>可能参与的角色：  </p>
<ul>
<li>开发</li>
<li>测试</li>
<li>DBA</li>
<li>运维</li>
</ul>
<h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><h3 id="数据层技术回顾"><a href="#数据层技术回顾" class="headerlink" title="数据层技术回顾"></a>数据层技术回顾</h3><ul>
<li>数据库设计与实现</li>
<li>MyBatis理解和使用技巧</li>
<li>MyBatis整合Spring技巧</li>
</ul>
<h3 id="业务层技术回顾"><a href="#业务层技术回顾" class="headerlink" title="业务层技术回顾"></a>业务层技术回顾</h3><ul>
<li>业务接口设计和封装</li>
<li>SpringIOC配置技巧</li>
<li>Spring声明式事务使用和理解</li>
</ul>
<h3 id="WEB技术回顾"><a href="#WEB技术回顾" class="headerlink" title="WEB技术回顾"></a>WEB技术回顾</h3><ul>
<li>Restful接口运用</li>
<li>Spring MVC使用技巧</li>
<li>前端交互分析过程</li>
<li>BootStrap和JavaScript使用</li>
</ul>
<h3 id="并发优化-1"><a href="#并发优化-1" class="headerlink" title="并发优化"></a>并发优化</h3><ul>
<li>系统瓶颈点分析</li>
<li>事务，锁和网络延迟的理解</li>
<li>前端，CDN，缓存等理解和使用</li>
<li>集群化部署</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://www.imooc.com/learn/587" target="_blank" rel="noopener">Java高并发秒杀API之业务分析与DAO层</a>  </li>
<li><a href="http://www.imooc.com/learn/631" target="_blank" rel="noopener">Java高并发秒杀API之Service层</a>  </li>
<li><a href="http://www.imooc.com/learn/630" target="_blank" rel="noopener">Java高并发秒杀API之Web层</a>  </li>
<li><a href="http://www.imooc.com/learn/632" target="_blank" rel="noopener">Java高并发秒杀API之高并发优化</a>  </li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">红发</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://AIpynux.github.io/2019/05/02/基于SSM实现高并发秒杀API课程笔记/">https://AIpynux.github.io/2019/05/02/基于SSM实现高并发秒杀API课程笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://AIpynux.github.io" target="_blank">红发</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SSM/">SSM</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/05/02/Ubuntu16.04关机太慢/"><i class="fa fa-chevron-left">  </i><span>Ubuntu16.04关机太慢</span></a></div><div class="next-post pull-right"><a href="/2019/03/19/MySQL使用笔记/"><span>MySQL使用笔记</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'b4621291d1504458073a',
  clientSecret: '4d6371f28956d1082d1d8450c8073485292b333e',
  repo: 'AIpynux.github.io',
  owner: 'AIpynux',
  admin: 'AIpynux',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 By 红发</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>