{"meta":{"title":"红发","subtitle":"常怀敬畏之心","description":"学习Java后端开发中","author":"红发","url":"https://AIpynux.github.io"},"pages":[{"title":"个人简介","date":"2019-02-19T16:40:27.511Z","updated":"2019-02-19T16:40:27.483Z","comments":true,"path":"about/index.html","permalink":"https://AIpynux.github.io/about/index.html","excerpt":"","text":"爱折腾，喜欢Linux，Vim预备党，正努力学习Java后端技术的CUMTer，95后。"},{"title":"分类","date":"2019-02-04T04:04:10.000Z","updated":"2019-02-19T09:51:59.160Z","comments":false,"path":"categories/index.html","permalink":"https://AIpynux.github.io/categories/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2019-01-21T14:46:30.048Z","updated":"2019-01-21T14:46:30.020Z","comments":true,"path":"friends/index.html","permalink":"https://AIpynux.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称: 红发头像: https://github.com/hgneer/Resource_of_Blogs/raw/master/Shanks.jpg网址: https://hgneer.github.io/标签: 爱折腾头像背景色值: #99001C"},{"title":"标签","date":"2019-02-04T04:00:38.000Z","updated":"2019-02-19T09:52:18.780Z","comments":false,"path":"tags/index.html","permalink":"https://AIpynux.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"廖雪峰Git教程笔记","slug":"廖雪峰Git教程笔记","date":"2019-02-24T12:47:12.000Z","updated":"2019-02-26T11:14:07.412Z","comments":true,"path":"2019/02/24/廖雪峰Git教程笔记/","link":"","permalink":"https://AIpynux.github.io/2019/02/24/廖雪峰Git教程笔记/","excerpt":"","text":"版本控制系统的作用 记录改动 协作编辑 Git的诞生Linus坚决反对CVS和SVN等集中式版本控制系统(因为速度慢且需要联网)–&gt;BitMover公司授权Linux社区商业软件BitKeeper免费使用权–&gt;Linus社区牛人试图破解BitKeeper的协议被BitMover公司发现–&gt;BitMover公司收回Linux社区BitKeeper免费使用权–&gt;Linus花两周时间用C语言写出了分布式版本控制系统Git 集中式VS分布式分布式在本地就可保存历史痕迹，不用担心污染服务器，集中式提交就到服务器了，如果提交出错就比较麻烦。集中式版本控制系统的版本库放在中央服务器，分布式版本控制系统的版本库每个人的电脑上都有。集中式版本控制系统必须联网才能使用,分布式版本控制系统不必联网就能使用。分布式版本控制系统的安全性更高，分支管理特别优秀。集中式如果单点故障，大家甚至无法提交更无法开分支。 有趣的小知识以前软件GNU Interactive Tools也叫GIT，所以老版本Linux安装git需要使用命令sudo apt-get install git-core。当然，之后随着Git的名气越来越大，后来GNU Interactive Tools改名成了gnuit，git-core正式改名为git。 Unix的哲学之一“没有消息就是好消息” Git命令行的使用 在git add之前可以用git diff查看指定文件具体修改内容。 在进行版本回退之前可以使用git log查看历史commit记录，Git的commit_id是用计算得出的哈希值表示。 HEAD表示当前版本，HEAD^表示上一版本，HEAD^^表示上上一个版本，HEAD~100表示往上100个版本。 一般使用git reset –hard commit_id进行版本穿梭,此时commit_id尤其重要。 使用git reflog查看历史命令可以确保回退到过去版本后依然能查询到未来版本的commit_id。 工作区是Working Directory，版本库是Repository，暂存区是stage(或index)。 git add把要提交的修改放到暂存区，git commit则可以一次性将暂存区的所有修改提交到分支。 Git比其它版本控制系统优秀的其中一个原因是Git跟踪并管理的是修改，而非文件。 git diff HEAD – &lt;文件名&gt;可以查看指定文件在工作区和版本库中的区别。 使用git checkout – &lt;文件名&gt;将指定文件在工作区的修改撤回，使用git reset HEAD &lt;文件名&gt;将指定文件提交到暂存区的修改撤回，使用git reset –hard commit_id等版本回退操作将提交到版本库的修改撤回。 使用rm &lt;文件名&gt;删除文件后，工作区和版本库就不一致了，git status就会提示我们哪些文件被删除了，如果确认在版本库中也要删除该文件则再使用git rm &lt;文件名&gt;。 Git的两级提交机制是一大杀器？ 使用git remote add origin &lt;远程仓库URL&gt;将本地版本库与远程仓库关联。 git push -u origin master第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 因为各个分支用指针来管理，git的分支切换几乎可在瞬间完成。 git merge &lt;branch_name&gt;用于合并指定分支到当前分支。 合并分支时有时提示Fast-forward表示此次合并是”快进模式”，也就是把分支指针移动一下。 因为创建、合并和删除分支非常快，所以Git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 合并对同一文件进行了不同修改的两个分支会出现冲突，此时用git status可以查看有哪些冲突的文件，之后打开对应文件会显示两个分支中该文件具体的不同。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 git log –graph –pretty=oneline –abbrev-commit可以查看分支合并图。 不要使用Fast forward模式合并，这样的合并删除分支后会丢失分支信息且从合并图看不出曾经做过合并。 平时应该使用非”快速模式”合并分支，git merge –no-ff -m &lt;”注释信息”&gt; &lt;branch_name&gt;，注意使用这种方式在merge时生成一个新的commit，所以这样合并后就可以从历史信息中看出合并信息。 日常使用分支管理开发时要保证master分支是稳定只用来发布新版本，平时都不在上面干活而是在分支dev上干活之后合并。 创建Bug分支并修复Bug然后合并前，针对当前未完成提交的dev分支工作环境，使用git stash进行存储；创建Bug分支并修复Bug然后合并后，使用git stash list查看保存的工作环境，使用git stash pop(恢复后删除stash记录)或git stash apply &lt;指定stash&gt;(恢复后不删除stash记录)恢复工作环境。 开发一个新的feature，最好新建一个分支；如果要丢弃一个没有合并过的分支，使用git branch -D &lt;branch_name&gt;强行删除。 多人协作时一般需要向远程推送master和dev分支，Bug分支一般不需要远程推送。 从远程克隆仓库下来后默认只看到master分支，使用git branch -b dev origin/dev创建远程dev分支到本地进行开发。 git pull失败原因一般是没有指定本地分支dev分支与远程origin/dev分支的链接，此时使用git branch –set-upstream-to=origin/dev dev设置它们之间链接后再git pull即可。 push前如果git pull成功但是与当前库合并出现冲突时还是先手动处理冲突，之后再push。 rebase操作可以把本地未push的分叉提交历史整理成直线，使查看历史提交的变化更容易？ Git的标签实际也是指向某个commit的指针，跟分支很像但是分支可以移动，标签不行。 tag是让人容易记住有意义的名字，他与某个commit绑在一起，但更humanity。 使用git tag &lt;tag_name&gt;默认是打在最新提交的commit上，当然也能打到指定commit上，需要在后面添加相应的commit_id。 git show &lt;tag_name&gt;查看标签详情，另外由于标签总是和某个commit绑在一起，如果这个commit在两个分支都有，那两个分支都能看到该commit对应的标签。 命令git tag -a &lt;tag_name&gt; -m “blablabla…”可以指定标签信息。 命令git push origin &lt;tag_name&gt;可以推送一个本地标签；命令git push origin –tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tag_name&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tag_name&gt;可以删除一个远程标签。 一个本地库关联多个远程库用git remote add多添加几个远程库URL即可。 可以使用git check-ignore检查.gitignore文件是否有哪条规则导致出错。","categories":[{"name":"编码笔记","slug":"编码笔记","permalink":"https://AIpynux.github.io/categories/编码笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://AIpynux.github.io/tags/Git/"}]},{"title":"Git命令行使用笔记","slug":"Git命令行使用笔记","date":"2019-02-24T07:48:16.000Z","updated":"2019-02-26T11:18:34.090Z","comments":true,"path":"2019/02/24/Git命令行使用笔记/","link":"","permalink":"https://AIpynux.github.io/2019/02/24/Git命令行使用笔记/","excerpt":"","text":"ssh debug1: Trying private key: /home/hgneer/.ssh/id_dsa debug1: Trying private key: /home/hgneer/.ssh/id_ecdsa debug1: Trying private key: /home/hgneer/.ssh/id_ed25519 重新创建ssh秘钥文件时一定注意公钥一般会发生变化，此时记得给Github添加公钥，避免不必要的麻烦。 DSA用在Github的SSH不行。 git clone/git init 如果用Github托管的话，一般先去Github建立Repository然后在自己主机clone会方便些；用git init的话在git remote添加远程主机地址时就要去创建Github的Repository来充当地址。 虽然Git本身支持多种协议的远程主机地址，且通常使用git协议的地址速度最快，但是Github代码托管平台却只提供https和ssh协议的地址。 git remote 可以修改.git中的config文件来改变远程主机地址，但是注意Github上只有Public的Repository才能使用git协议的地址作为Git的远程主机地址。 自己添加远程主机的名字最好不要写成origin。 注意从远程主机clone下来后默认远程主机名是origin，可以用git clone -o &lt;想要的主机名&gt; 主机地址。 git fetch git fetch &lt;远程主机名&gt; &lt;远程分支名&gt; fetch得到的分支在Repository，之后通过checkout创建一个本地分支或者merge得到的分支或者rebase得到的分支 git merge是合并分支到当前分支，不管是本地分支还是远程分支 git rebase暂时不要用，留到后面理解，rebase是一种合并方式? git pull 取回远程分支的更新再与本地某分支合并 git pull &lt;远程主机名&gt; &lt;远程分支名&gt; : &lt;本地分支名&gt; 相当于git fetch + git merge -p可以使得在本地删除远程已删除的分支 git pull &lt;远程主机名&gt;表示与本分支的追踪分支进行更新及合并 git push 把本地的更新推送到远程并合并 git push &lt;远程主机名&gt; &lt;本地分支名&gt; : &lt;远程分支名&gt; (&lt;来源地&gt; : &lt;目的地&gt;) 省掉远程分支名则表示与追踪分支保持一致来推送 省掉本地分支名则表示推送一个空分支到远程分支，效果是删除远程分支 当本地分支与多个远程主机存在追踪关系可以用-u来选择默认远程主机 推送程度:simple(当前分支)、matching(所有对应远程分支的本地分支)、all（所有分支） 如果远程分支比本地分支新，git push 之前一般需要 git pull git push不会推送tags，除非加上–tags before git push,git fetch first and then git merge,or JUST git pull –rebase. git tag 标签命名与commit注释有关？ git log git log –name-status git log –author=hgneer git log –pretty=oneline git log –graph –oneline –decorate –all git branch git branch &lt;分支名&gt;是新建一个分支但不改变当前分支，git checkout -b &lt;分支名&gt;是新建一个分支并切换到该分支 git checkout - 切换到上一分支 git branch –set-upstream-to=&lt;远程分支名&gt;是为当前分支建立追踪分支 git commit git commit -v提交时显示所有diff信息在最下方 git commit –amend 可以修改制定commit对应的注释 撤销 git log 找到你想撤销的commit_id哈希值 git reset commit_id哈希值 完成Commit命令的撤销，但是不对代码修改进行撤销， git reset –keep commit_id哈希值 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git reset –hard commit_id哈希值 完成撤销,同时将代码恢复到前一commit_id 对应的版本。","categories":[{"name":"编码笔记","slug":"编码笔记","permalink":"https://AIpynux.github.io/categories/编码笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://AIpynux.github.io/tags/Git/"}]},{"title":"几个图片共享网址","slug":"几个图片共享网址","date":"2019-02-24T07:10:25.000Z","updated":"2019-02-24T07:43:25.015Z","comments":true,"path":"2019/02/24/几个图片共享网址/","link":"","permalink":"https://AIpynux.github.io/2019/02/24/几个图片共享网址/","excerpt":"","text":"汇图网 全景网 拍信网 给图网 视觉中国 红动中国 DreamsTime","categories":[{"name":"生活笔记","slug":"生活笔记","permalink":"https://AIpynux.github.io/categories/生活笔记/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://AIpynux.github.io/tags/资源/"}]},{"title":"配置Hexo主题之Melody","slug":"配置Hexo主题之Melody","date":"2019-02-03T09:22:10.000Z","updated":"2019-02-05T13:34:20.439Z","comments":true,"path":"2019/02/03/配置Hexo主题之Melody/","link":"","permalink":"https://AIpynux.github.io/2019/02/03/配置Hexo主题之Melody/","excerpt":"","text":"遇到问题使用Hexo的data file特性新建Melody主题的melody.yml配置文件后，将个人博客部署到本地，输入本地URL后，浏览器没有响应，提示代码如下: 123456789101112131415161718192021Unhandled rejection TypeError: /home/hgneer/Hexo/themes/melody/layout/includes/layout.pug:31 29| each url in theme.stylesheets 30| link(rel=&apos;stylesheet&apos;, href=url_for(url) + &apos;?version=&apos; + version()) &gt; 31| each item in theme.cdn.css 32| if item !== undefined 33| link(rel=&apos;stylesheet&apos;, href=item + &apos;?version=&apos; + version()) 34| include ./head.pugCannot read property &apos;css&apos; of undefined at eval (eval at wrap (/home/hgneer/Hexo/node_modules/pug-runtime/wrap.js:6:10), &lt;anonymous&gt;:80:25) at eval (eval at wrap (/home/hgneer/Hexo/node_modules/pug-runtime/wrap.js:6:10), &lt;anonymous&gt;:102:4) at template (eval at wrap (/home/hgneer/Hexo/node_modules/pug-runtime/wrap.js:6:10), &lt;anonymous&gt;:1657:72) at Theme._View.View._compiled.locals [as _compiled] (/home/hgneer/Hexo/node_modules/hexo/lib/theme/view.js:125:48) at Theme._View.View.View.render (/home/hgneer/Hexo/node_modules/hexo/lib/theme/view.js:30:15) at route.set (/home/hgneer/Hexo/node_modules/hexo/lib/hexo/index.js:394:29) at tryCatcher (/home/hgneer/Hexo/node_modules/bluebird/js/release/util.js:16:23) at /home/hgneer/Hexo/node_modules/bluebird/js/release/method.js:15:34 at RouteStream._read (/home/hgneer/Hexo/node_modules/hexo/lib/hexo/router.js:134:3) at RouteStream.Readable.read (_stream_readable.js:452:10) at resume_ (_stream_readable.js:899:12) at process._tickCallback (internal/process/next_tick.js:63:19) 解决办法需要复制到Hexo/source/_data下的_config.yml是melody主题目录下的而非Hexo目录下的。 待用特性 Slide页面(利用reveal.js) 相册页面-","categories":[{"name":"编码笔记","slug":"编码笔记","permalink":"https://AIpynux.github.io/categories/编码笔记/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://AIpynux.github.io/tags/Hexo/"}]},{"title":"可选发型","slug":"可选发型","date":"2019-01-31T08:53:55.000Z","updated":"2019-02-03T08:46:27.913Z","comments":true,"path":"2019/01/31/可选发型/","link":"","permalink":"https://AIpynux.github.io/2019/01/31/可选发型/","excerpt":"","text":"短发 板寸 碎发 莫西干 中发 复古油头","categories":[{"name":"生活笔记","slug":"生活笔记","permalink":"https://AIpynux.github.io/categories/生活笔记/"}],"tags":[]},{"title":"为Github账户设置GPG认证","slug":"为Github账户设置GPG认证","date":"2019-01-31T06:28:35.000Z","updated":"2019-02-04T04:11:18.069Z","comments":true,"path":"2019/01/31/为Github账户设置GPG认证/","link":"","permalink":"https://AIpynux.github.io/2019/01/31/为Github账户设置GPG认证/","excerpt":"概述GPG密钥算法旨在完成文件传输过程中的加密工作。 Github支持的GPG密钥算法: RSA ElGamal DSA ECDH ECDSA EdDSA 为Github账户设置GPG认证的好处: 可以限制使得对项目的commit必须经过认证后才能merge。 让项目使用者明晰哪些commit是官方认证哪些又是未经许可。","text":"概述GPG密钥算法旨在完成文件传输过程中的加密工作。 Github支持的GPG密钥算法: RSA ElGamal DSA ECDH ECDSA EdDSA 为Github账户设置GPG认证的好处: 可以限制使得对项目的commit必须经过认证后才能merge。 让项目使用者明晰哪些commit是官方认证哪些又是未经许可。 查看已有GPG密钥1gpg --list-secret-keys --keyid-format LONG 创建GPG密钥1gpg --gen-key 添加密钥到Github账户查看已创建的密钥，从中选择要添加到Github的密钥ID是6DD5E93799EE33C7。 12345678910$ gpg --list-secret-keys --keyid-format LONG/home/hgneer/.gnupg/secring.gpg-------------------------------sec 2048R/BCA9B4B1BA4C13CE 2017-04-05uid HeGuang (GPG key for HeGuang) &lt;hgneer@gmail.com&gt;ssb 2048R/D0B0CD73B2553FBB 2017-04-05sec 4096R/6DD5E93799EE33C7 2019-01-31uid AIpynux (New World!) &lt;AIpynux@gmail.com&gt;ssb 4096R/2C344A43117B0512 2019-01-31 使用如下命令将ID是6DD5E93799EE33C7的密钥的公钥输出到终端显示。 1gpg --armor --export 6DD5E93799EE33C7 之后将得到的像下面格式一样的文本复制Github账户的GPG密钥设置框。 —–BEGIN PGP PUBLIC KEY BLOCK—–公钥内容—–END PGP PUBLIC KEY BLOCK—–. 为本地Git设置全局GPG密钥ID1git config --global user.signingkey 6DD5E93799EE33C7 参考链接 GPG入门教程 Managing commit signature verification","categories":[{"name":"编码笔记","slug":"编码笔记","permalink":"https://AIpynux.github.io/categories/编码笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://AIpynux.github.io/tags/Git/"},{"name":"GPG","slug":"GPG","permalink":"https://AIpynux.github.io/tags/GPG/"}]},{"title":"Vim无插件实现Markdown预览","slug":"Vim无插件Markdown预览","date":"2019-01-20T06:58:53.000Z","updated":"2019-02-02T04:11:50.005Z","comments":true,"path":"2019/01/20/Vim无插件Markdown预览/","link":"","permalink":"https://AIpynux.github.io/2019/01/20/Vim无插件Markdown预览/","excerpt":"环境 chromium-browser Markdown Viewer Ubuntu16.04 Vim","text":"环境 chromium-browser Markdown Viewer Ubuntu16.04 Vim 步骤 确保chromium-browser可以从终端输入命令启动。 为chromium安装Markdown Viewer插件 在~/.vimrc中添加如下代码: 123456nmap &lt;F4&gt; :call Preview()&lt;CR&gt;func! Preview() if &amp;filetype == &apos;markdown.mkd&apos; exec &quot;!chromium-browser %&quot; endifendfunc 效果用Vim编辑Markdown文件时按F4会打开一个chromium窗口进行预览,每次保存文件时更新预览。 注意不要用Firefox，Firefox自动对离线文件的编码解析总不准确且不能修改默认的离线文件编码为Unicode，所以总是造成乱码。 参考Vim无插件实现Markdown文件实时预览","categories":[{"name":"Tools","slug":"Tools","permalink":"https://AIpynux.github.io/categories/Tools/"},{"name":"Vim","slug":"Tools/Vim","permalink":"https://AIpynux.github.io/categories/Tools/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://AIpynux.github.io/tags/Vim/"}]},{"title":"Improve the Speed of Git Clone from Github","slug":"Improve_the_Speed_of_Git_Clone_from_Github","date":"2019-01-20T06:57:53.000Z","updated":"2019-02-04T04:22:54.285Z","comments":true,"path":"2019/01/20/Improve_the_Speed_of_Git_Clone_from_Github/","link":"","permalink":"https://AIpynux.github.io/2019/01/20/Improve_the_Speed_of_Git_Clone_from_Github/","excerpt":"出现障碍更新Vim到8.1后检查插件状态，发现ale需要重新安装。 用的插件管理器是Vim-Plug，在.vimrc.bundles中添加: 1Plug &apos;w0rp/ale&apos; 之后在Vim中执行命令 :PlugInstall 看着屏幕上的进度条一点点地跑到终点，终端却抛来如下错误:","text":"出现障碍更新Vim到8.1后检查插件状态，发现ale需要重新安装。 用的插件管理器是Vim-Plug，在.vimrc.bundles中添加: 1Plug &apos;w0rp/ale&apos; 之后在Vim中执行命令 :PlugInstall 看着屏幕上的进度条一点点地跑到终点，终端却抛来如下错误: 1234error: RPC failed; curl 18 transfer closed with outstanding read data remainingfatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 分析原因看上诉错误的字面意思是下载的包在传输过程中提前结束。我以为凑巧出错便重新下载。 经过实验多次，这样的错误发生不是偶然。之后,经过查阅文档,我发现Vim-Plug实际上采 用git来下载安装Github上的插件项目。然而,国内用终端克隆Github上Repository速度特慢, 猜测此次障碍可能由此造成。 解决办法1. 为git设置代理在设置了SS代理的前提下，从终端输入: 12git config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080 2. 修改Hosts用以下命令查找github.global.ssl.fastly.Net和github.com对应的IP地址:12nslookup github.global.ssl.fastly.Netnslookup github.com 之后将IP地址和域名对添加到/etc/hosts文件。 最终效果git clone的速度从10.0KB/s提升到150.0KB/s;出现的插件下载安装障碍得到解决。 参考文章git clone速度太慢解决方案 git clone一个github上的仓库，太慢…","categories":[{"name":"Tools","slug":"Tools","permalink":"https://AIpynux.github.io/categories/Tools/"},{"name":"Git","slug":"Tools/Git","permalink":"https://AIpynux.github.io/categories/Tools/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://AIpynux.github.io/tags/Git/"}]},{"title":"Ubuntu16.04备份重装成根目录可扩容LVM方式Linux系统","slug":"Ubuntu16.04备份重装成根目录可扩容的LVM方式Linux系统","date":"2019-01-20T06:56:53.000Z","updated":"2019-02-04T01:57:19.880Z","comments":true,"path":"2019/01/20/Ubuntu16.04备份重装成根目录可扩容的LVM方式Linux系统/","link":"","permalink":"https://AIpynux.github.io/2019/01/20/Ubuntu16.04备份重装成根目录可扩容的LVM方式Linux系统/","excerpt":"说明:为了区分原先系统和重装后系统以及述说方便，将原先系统称作Ubuntu1，重装后系统称作Ubuntu2。 先看一下我Ubuntu1的一些信息：","text":"说明:为了区分原先系统和重装后系统以及述说方便，将原先系统称作Ubuntu1，重装后系统称作Ubuntu2。 先看一下我Ubuntu1的一些信息： 一、备份进入Ubuntu1，输入su root切换root，将设备/dev/sdb1（选一个你机器上有空余空间未挂载的分区）挂载到/tmp。终端输入tar -cvpzf /tmp/back/back.tgz / –exclude=/proc –exclude=/lost+found –exclude=/tmp –exclude=/sys –exclude=/media。将Ubuntu1上所有挂载在/目录下的文件(除了/目录下proc、lost+found、tmp、sys和media文件夹)压缩在已挂载/dev/sdb1设备的目录/tmp的back文件夹下，并命名为back.tgz。 12345注意：1. /tmp下的back文件夹须事先创建。2. 备份时勿包括/dev/sdb1所挂载的目录（此处为/tmp）。3. 记下那些备份时未包括进来的目录（即proc等），最后恢复时需要手动mkdir创建，否则系统会出错。4. 最后压缩结束后可能会出现 tar: 由于前次错误，将以上次的错误状态退出。这个不用理会即可。 二、分配磁盘右击此电脑–&gt;管理 得到计算机管理窗口–&gt;点击磁盘管理–&gt;右键单击选择要压缩的磁盘 在输入压缩空间量（MB）里填写要压缩出的空间量,我这里压缩50G–&gt;压缩 注：这里得到未分配的磁盘为待会我们用Linux进行LVM式分区做准备。(电脑若有有空闲空间的设备直接跳过此步骤到第三步进行分区） 三、分区制作Ubuntu16.04的U盘启动盘，进入试用即LiveCD模式。首先在终端输入sudo passwd root，改变试用系统下root用户的密码。之后输入su root切换成root用户，之后的大多操作都需要root权限。 终端输入fdisk -l找到划分好有空闲空间的磁盘设备名。 我主机上有未分配磁盘空间的设备是/dev/sdb。所以终端输入fdisk /dev/sdb。输入n新建一个分区(/dev/sdb6)。分区号为6–&gt;分区起始扇区按回车默认设置–&gt;分区终结扇区输入+49G，代表起始扇区往后数49G的扇区，意味给分区分配49G。此分区待会制成lv时会分成给Ubuntu2的/、swap交换空间和/home对应的三个lv分区，此时先成一个就好,但需将分区类型标志改成LVM。 输入t改变分区标志–&gt;分区号为6–&gt;输入L查找代表LVM的代码–&gt;查得30代表LVM，输入30，修改标志成功。 输入n新建另一个分区(sdb7)对应给Ubuntu2的/boot，分配剩下的1G给此分区，此分区不需要改成LVM，不改标志。 输入p查看分区是否正确，确认无误后输入w写入并退出fdisk。 终端输入partprobe更新分区信息。再输入fdisk -l /dev/sdb查看分区创建成功否。 四、创建PV、VG、LV终端输入pvcreate /dev/sdb6创建pv，输入pvscan查看目前有哪些pv检查创建成功否。终端输入vgcreate hgneer1 /dev/sdb6创建名字为hgneer1（随自己定义的名字）的vg，输入vgscan查看目前有哪些pv检查创建成功否。终端输入lvcreate -L +25G -n root hgneer1（刚才创建的vg），表示创建一个大小为25G的/dev/mapper/hgneer1-root的lv分区，预定作为Ubuntu2的/对应的分区。终端输入lvcreate -L +8G -n swap hgneer1（刚才创建的vg），表示创建一个大小为8G的/dev/mapper/hgneer1-swap的lv分区，预定作为Ubuntu2的swap交换空间对应的分区。终端输入lvcreate -L +16G -n home hgneer1（刚才创建的vg），表示创建一个大小为16G的/dev/mapper/hgneer1-home的lv分区，预定作为Ubuntu2的/home对应的分区。终端输入lvscan检查所需lv创建成功否。确认无误后，lvm分区真正创建。 五、重装系统点击桌面上的“install Ubuntu16.04.3 LTS”开始安装 安装时选择其他选项，自行分区选择调整。/dev/mapper/hgneer1-home分区挂载到/home目录，选中格式化成Ext4日志文件系统/dev/mapper/hgneer1-root分区挂载到/目录，选中格式化成Ext4日志文件系统/dev/mapper/hgneer1-swap分区作为swap交换空间/dev/sdb7分区挂载到/boot目录，选中格式化成Ext4日志文件系统另外注意安装启动引导器的设备选择挂载到/boot目录的/dev/sdb7，否则很可能无法引导出Linux系统！！！ 等待安装成功后，先不要重启，继续试用，看新装上的系统Ubuntu2是否使用了LVM。终端输入mount /dev/mapper/hgneer-root /mnt挂载Ubuntu2的/到试用系统的/mnt。终端输入mount /dev/mapper/hgneer-home /mnt/home挂载Ubuntu2的/home到试用系统的/mnt/home。终端输入mount /dev/sdb7 /mnt挂载Ubuntu2的/boot到试用系统的/mnt/boot。cd到上面几个目录下看下，确定不为空系统成功装上后终端输入chroot /mnt将/mnt改成根目录，而后关机。 六、恢复数据及配置重启进入Ubuntu2系统。将/etc/fstab文件及/boot目录备份到挂载了/dev/sdb1的/tmp的back文件夹中。这些文件记载了Ubuntu2的启动信息以及Ubuntu2各重要目录所在的分区信息，这些文件与Ubuntu1不一样的因此在之后解压备份文件后需要把这些文件替换到对应目录下。 重启进入liveCD（U盘启动盘试用）。照前文一样命令获取试用系统的root权限。 终端输入mount /dev/mapper/hgneer-root /mnt挂载Ubuntu2的/到试用系统的/mnt。 终端输入mount /dev/mapper/hgneer-home /mnt/home挂载Ubuntu2的/home到试用系统的/mnt/home。 终端输入mount /dev/sdb7 /mnt/boot挂载Ubuntu2的/boot到试用系统的/mnt/boot。 cd到/mnt目录后，终端输入ls | xargs rm -rf，删除Ubuntu2系统根目录下的全部目录及文件。 终端输入mount /dev/sdb1 /tmp挂载D盘到/tmp目录，cd到/tmp/back后终端输入tar -xvpf back.tgz -C /mnt。 最终目的将Ubuntu1的备份下数据文件解压到/mnt即Ubuntu2的根目录下。 等到解压完成后cd到/mnt后，终端输入mkdir proc lost+found tmp sys media，创建Ubuntu1备份时未选中的目录。将备份在设备/dev/sdb1即现挂载在/tmp目录下的back文件夹中的fstab拷贝替换到/mnt/etc目录下。将备份在设备/dev/sdb1即现挂载在/tmp目录下的back文件夹中的/boot文件夹中的文件拷贝到/mnt/boot目录下。终端输入chroot /mnt转换/mnt当作根目录。重启进入Ubuntu2，根目录可扩容且用户数据配置与Ubuntu1完全一致的Linux系统完成！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://AIpynux.github.io/categories/Linux/"},{"name":"Ubuntu","slug":"Linux/Ubuntu","permalink":"https://AIpynux.github.io/categories/Linux/Ubuntu/"},{"name":"磁盘阵列","slug":"磁盘阵列","permalink":"https://AIpynux.github.io/categories/磁盘阵列/"},{"name":"LVM","slug":"磁盘阵列/LVM","permalink":"https://AIpynux.github.io/categories/磁盘阵列/LVM/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://AIpynux.github.io/tags/Ubuntu/"}]}]}