<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红发</title>
  
  <subtitle>常怀敬畏之心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://AIpynux.github.io/"/>
  <updated>2019-02-26T11:23:52.343Z</updated>
  <id>https://AIpynux.github.io/</id>
  
  <author>
    <name>红发</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>廖雪峰Git教程笔记</title>
    <link href="https://AIpynux.github.io/2019/02/24/%E5%BB%96%E9%9B%AA%E5%B3%B0Git%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://AIpynux.github.io/2019/02/24/廖雪峰Git教程笔记/</id>
    <published>2019-02-24T12:47:12.000Z</published>
    <updated>2019-02-26T11:23:52.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制系统的作用"><a href="#版本控制系统的作用" class="headerlink" title="版本控制系统的作用"></a>版本控制系统的作用</h2><ul><li>记录改动</li><li>协作编辑</li></ul><h2 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h2><p>Linus坚决反对CVS和SVN等集中式版本控制系统(因为速度慢且需要联网)<br>–&gt;BitMover公司授权Linux社区商业软件BitKeeper免费使用权<br>–&gt;Linus社区牛人试图破解BitKeeper的协议被BitMover公司发现<br>–&gt;BitMover公司收回Linux社区BitKeeper免费使用权<br>–&gt;Linus花两周时间用C语言写出了分布式版本控制系统Git</p><a id="more"></a><h2 id="集中式VS分布式"><a href="#集中式VS分布式" class="headerlink" title="集中式VS分布式"></a>集中式VS分布式</h2><p>分布式在本地就可保存历史痕迹，不用担心污染服务器，集中式提交就到服务器了，如果提交出错就比较麻烦。<br>集中式版本控制系统的版本库放在中央服务器，分布式版本控制系统的版本库每个人的电脑上都有。<br>集中式版本控制系统必须联网才能使用,分布式版本控制系统不必联网就能使用。<br>分布式版本控制系统的安全性更高，分支管理特别优秀。<br>集中式如果单点故障，大家甚至无法提交更无法开分支。  </p><h2 id="有趣的小知识"><a href="#有趣的小知识" class="headerlink" title="有趣的小知识"></a>有趣的小知识</h2><p>以前软件GNU Interactive Tools也叫GIT，所以老版本Linux安装git需要使用命令sudo apt-get install git-core。<br>当然，之后随着Git的名气越来越大，后来GNU Interactive Tools改名成了gnuit，git-core正式改名为git。</p><h2 id="Unix的哲学之一"><a href="#Unix的哲学之一" class="headerlink" title="Unix的哲学之一"></a>Unix的哲学之一</h2><p>“没有消息就是好消息”</p><h2 id="Git命令行的使用"><a href="#Git命令行的使用" class="headerlink" title="Git命令行的使用"></a>Git命令行的使用</h2><ol><li>在git add之前可以用git diff查看指定文件具体修改内容。</li><li>在进行版本回退之前可以使用git log查看历史commit记录，Git的commit_id是用计算得出的哈希值表示。</li><li>HEAD表示当前版本，HEAD^表示上一版本，HEAD^^表示上上一个版本，HEAD~100表示往上100个版本。</li><li>一般使用git reset –hard commit_id进行版本穿梭,此时commit_id尤其重要。</li><li>使用git reflog查看历史命令可以确保回退到过去版本后依然能查询到未来版本的commit_id。</li><li>工作区是Working Directory，版本库是Repository，暂存区是stage(或index)。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/%E5%BB%96%E9%9B%AA%E5%B3%B0Git%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/1.jpeg" alt=""></li><li>git add把要提交的修改放到暂存区，git commit则可以一次性将暂存区的所有修改提交到分支。</li><li>Git比其它版本控制系统优秀的其中一个原因是Git跟踪并管理的是修改，而非文件。</li><li>git diff HEAD – &lt;文件名&gt;可以查看指定文件在工作区和版本库中的区别。</li><li>使用git checkout – &lt;文件名&gt;将指定文件在工作区的修改撤回，使用git reset HEAD &lt;文件名&gt;将指定文件提交到暂存区的修改撤回，使用git reset –hard commit_id等版本回退操作将提交到版本库的修改撤回。</li><li>使用rm &lt;文件名&gt;删除文件后，工作区和版本库就不一致了，git status就会提示我们哪些文件被删除了，如果确认在版本库中也要删除该文件则再使用git rm &lt;文件名&gt;。</li><li>Git的两级提交机制是一大杀器？</li><li>使用git remote add origin &lt;远程仓库URL&gt;将本地版本库与远程仓库关联。</li><li>git push -u origin master第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</li><li>因为各个分支用指针来管理，git的分支切换几乎可在瞬间完成。</li><li>git merge &lt;branch_name&gt;用于合并指定分支到当前分支。</li><li>合并分支时有时提示Fast-forward表示此次合并是”快进模式”，也就是把分支指针移动一下。</li><li>因为创建、合并和删除分支非常快，所以Git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</li><li>合并对同一文件进行了不同修改的两个分支会出现冲突，此时用git status可以查看有哪些冲突的文件，之后打开对应文件会显示两个分支中该文件具体的不同。</li><li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li><li>git log –graph –pretty=oneline –abbrev-commit可以查看分支合并图。</li><li>不要使用Fast forward模式合并，这样的合并删除分支后会丢失分支信息且从合并图看不出曾经做过合并。</li><li>平时应该使用非”快速模式”合并分支，git merge –no-ff -m &lt;”注释信息”&gt; &lt;branch_name&gt;，注意使用这种方式在merge时生成一个新的commit，所以这样合并后就可以从历史信息中看出合并信息。</li><li>日常使用分支管理开发时要保证master分支是稳定只用来发布新版本，平时都不在上面干活而是在分支dev上干活之后合并。</li><li>创建Bug分支并修复Bug然后合并前，针对当前未完成提交的dev分支工作环境，使用git stash进行存储；创建Bug分支并修复Bug然后合并后，使用git stash list查看保存的工作环境，使用git stash pop(恢复后删除stash记录)或git stash apply &lt;指定stash&gt;(恢复后不删除stash记录)恢复工作环境。</li><li>开发一个新的feature，最好新建一个分支；如果要丢弃一个没有合并过的分支，使用git branch -D &lt;branch_name&gt;强行删除。</li><li>多人协作时一般需要向远程推送master和dev分支，Bug分支一般不需要远程推送。</li><li>从远程克隆仓库下来后默认只看到master分支，使用git branch -b dev origin/dev创建远程dev分支到本地进行开发。</li><li>git pull失败原因一般是没有指定本地分支dev分支与远程origin/dev分支的链接，此时使用git branch –set-upstream-to=origin/dev dev设置它们之间链接后再git pull即可。</li><li>push前如果git pull成功但是与当前库合并出现冲突时还是先手动处理冲突，之后再push。</li><li>rebase操作可以把本地未push的分叉提交历史整理成直线，使查看历史提交的变化更容易？</li><li>Git的标签实际也是指向某个commit的指针，跟分支很像但是分支可以移动，标签不行。</li><li>tag是让人容易记住有意义的名字，他与某个commit绑在一起，但更humanity。</li><li>使用git tag &lt;tag_name&gt;默认是打在最新提交的commit上，当然也能打到指定commit上，需要在后面添加相应的commit_id。</li><li>git show &lt;tag_name&gt;查看标签详情，另外由于标签总是和某个commit绑在一起，如果这个commit在两个分支都有，那两个分支都能看到该commit对应的标签。</li><li>命令git tag -a &lt;tag_name&gt; -m “blablabla…”可以指定标签信息。</li><li>命令git push origin &lt;tag_name&gt;可以推送一个本地标签；命令git push origin –tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tag_name&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tag_name&gt;可以删除一个远程标签。</li><li>一个本地库关联多个远程库用git remote add多添加几个远程库URL即可。</li><li>可以使用git check-ignore检查.gitignore文件是否有哪条规则导致出错。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本控制系统的作用&quot;&gt;&lt;a href=&quot;#版本控制系统的作用&quot; class=&quot;headerlink&quot; title=&quot;版本控制系统的作用&quot;&gt;&lt;/a&gt;版本控制系统的作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;记录改动&lt;/li&gt;
&lt;li&gt;协作编辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Git的诞生&quot;&gt;&lt;a href=&quot;#Git的诞生&quot; class=&quot;headerlink&quot; title=&quot;Git的诞生&quot;&gt;&lt;/a&gt;Git的诞生&lt;/h2&gt;&lt;p&gt;Linus坚决反对CVS和SVN等集中式版本控制系统(因为速度慢且需要联网)&lt;br&gt;–&amp;gt;BitMover公司授权Linux社区商业软件BitKeeper免费使用权&lt;br&gt;–&amp;gt;Linus社区牛人试图破解BitKeeper的协议被BitMover公司发现&lt;br&gt;–&amp;gt;BitMover公司收回Linux社区BitKeeper免费使用权&lt;br&gt;–&amp;gt;Linus花两周时间用C语言写出了分布式版本控制系统Git&lt;/p&gt;
    
    </summary>
    
      <category term="编码笔记" scheme="https://AIpynux.github.io/categories/%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://AIpynux.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git命令行使用笔记</title>
    <link href="https://AIpynux.github.io/2019/02/24/Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://AIpynux.github.io/2019/02/24/Git命令行使用笔记/</id>
    <published>2019-02-24T07:48:16.000Z</published>
    <updated>2019-02-26T11:24:31.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><ul><li>debug1: Trying private key: /home/hgneer/.ssh/id_dsa</li><li>debug1: Trying private key: /home/hgneer/.ssh/id_ecdsa</li><li>debug1: Trying private key: /home/hgneer/.ssh/id_ed25519</li><li>重新创建ssh秘钥文件时一定注意公钥一般会发生变化，<br>此时记得给Github添加公钥，避免不必要的麻烦。</li><li>DSA用在Github的SSH不行。</li></ul><h1 id="git-clone-git-init"><a href="#git-clone-git-init" class="headerlink" title="git clone/git init"></a>git clone/git init</h1><ul><li>如果用Github托管的话，一般先去Github建立Repository然后在自己主机clone会方便些；<br>用git init的话在git remote添加远程主机地址时就要去创建Github的Repository来充当地址。</li><li><p>虽然Git本身支持多种协议的远程主机地址，且通常使用git协议的地址速度最快，<br>但是Github代码托管平台却只提供https和ssh协议的地址。</p><a id="more"></a></li></ul><h1 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h1><ul><li>可以修改.git中的config文件来改变远程主机地址，<br>但是注意Github上只有Public的Repository才能使用git协议的地址作为Git的远程主机地址。</li><li>自己添加远程主机的名字最好不要写成origin。</li><li>注意从远程主机clone下来后默认远程主机名是origin，可以用git clone -o &lt;想要的主机名&gt; 主机地址。</li></ul><h1 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h1><ul><li>git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;</li><li>fetch得到的分支在Repository，<br>之后通过checkout创建一个本地分支或者merge得到的分支或者rebase得到的分支</li><li>git merge是合并分支到当前分支，不管是本地分支还是远程分支</li><li>git rebase暂时不要用，留到后面理解，rebase是一种合并方式?</li></ul><h1 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h1><ul><li>取回远程分支的更新再与本地某分支合并</li><li>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;  : &lt;本地分支名&gt;</li><li>相当于git fetch + git merge</li><li>-p可以使得在本地删除远程已删除的分支</li><li>git pull &lt;远程主机名&gt;表示与本分支的追踪分支进行更新及合并</li></ul><h1 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h1><ul><li>把本地的更新推送到远程并合并</li><li>git push &lt;远程主机名&gt; &lt;本地分支名&gt; : &lt;远程分支名&gt; (&lt;来源地&gt; : &lt;目的地&gt;)</li><li>省掉远程分支名则表示与追踪分支保持一致来推送</li><li>省掉本地分支名则表示推送一个空分支到远程分支，效果是删除远程分支</li><li>当本地分支与多个远程主机存在追踪关系可以用-u来选择默认远程主机</li><li>推送程度:simple(当前分支)、matching(所有对应远程分支的本地分支)、all（所有分支）</li><li>如果远程分支比本地分支新，git push 之前一般需要 git pull</li><li>git push不会推送tags，除非加上–tags</li><li>before git push,git fetch first and then git merge,or JUST git pull –rebase.</li></ul><h1 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h1><ul><li>标签命名与commit注释有关？</li></ul><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><ul><li>git log –name-status</li><li>git log –author=hgneer</li><li>git log –pretty=oneline</li><li>git log –graph –oneline –decorate –all</li></ul><h1 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h1><ul><li>git branch &lt;分支名&gt;是新建一个分支但不改变当前分支，<br>git checkout -b &lt;分支名&gt;是新建一个分支并切换到该分支</li><li>git checkout - 切换到上一分支</li><li>git branch –set-upstream-to=&lt;远程分支名&gt;是为当前分支建立追踪分支</li></ul><h1 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h1><ul><li>git commit -v提交时显示所有diff信息在最下方</li><li>git commit –amend 可以修改制定commit对应的注释</li></ul><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><ul><li>git log 找到你想撤销的commit_id哈希值</li><li>git reset commit_id哈希值 完成Commit命令的撤销，但是不对代码修改进行撤销，  </li><li>git reset –keep commit_id哈希值 重置当前HEAD为指定commit，但保持暂存区和工作区不变</li><li>git reset –hard commit_id哈希值 完成撤销,同时将代码恢复到前一commit_id 对应的版本。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ssh&quot;&gt;&lt;a href=&quot;#ssh&quot; class=&quot;headerlink&quot; title=&quot;ssh&quot;&gt;&lt;/a&gt;ssh&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;debug1: Trying private key: /home/hgneer/.ssh/id_dsa&lt;/li&gt;
&lt;li&gt;debug1: Trying private key: /home/hgneer/.ssh/id_ecdsa&lt;/li&gt;
&lt;li&gt;debug1: Trying private key: /home/hgneer/.ssh/id_ed25519&lt;/li&gt;
&lt;li&gt;重新创建ssh秘钥文件时一定注意公钥一般会发生变化，&lt;br&gt;此时记得给Github添加公钥，避免不必要的麻烦。&lt;/li&gt;
&lt;li&gt;DSA用在Github的SSH不行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;git-clone-git-init&quot;&gt;&lt;a href=&quot;#git-clone-git-init&quot; class=&quot;headerlink&quot; title=&quot;git clone/git init&quot;&gt;&lt;/a&gt;git clone/git init&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;如果用Github托管的话，一般先去Github建立Repository然后在自己主机clone会方便些；&lt;br&gt;用git init的话在git remote添加远程主机地址时就要去创建Github的Repository来充当地址。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虽然Git本身支持多种协议的远程主机地址，且通常使用git协议的地址速度最快，&lt;br&gt;但是Github代码托管平台却只提供https和ssh协议的地址。&lt;/p&gt;
    
    </summary>
    
      <category term="编码笔记" scheme="https://AIpynux.github.io/categories/%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://AIpynux.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>几个图片共享网址</title>
    <link href="https://AIpynux.github.io/2019/02/24/%E5%87%A0%E4%B8%AA%E5%9B%BE%E7%89%87%E5%85%B1%E4%BA%AB%E7%BD%91%E5%9D%80/"/>
    <id>https://AIpynux.github.io/2019/02/24/几个图片共享网址/</id>
    <published>2019-02-24T07:10:25.000Z</published>
    <updated>2019-02-24T07:43:25.015Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://www.huitu.com/" target="_blank" rel="noopener">汇图网</a></li><li><a href="https://www.quanjing.com/" target="_blank" rel="noopener">全景网</a></li><li><a href="https://www.paixin.com/" target="_blank" rel="noopener">拍信网</a></li><li><a href="https://www.geitu.net/" target="_blank" rel="noopener">给图网</a></li><li><a href="https://www.vcg.com/" target="_blank" rel="noopener">视觉中国</a></li><li><a href="http://www.redocn.com/" target="_blank" rel="noopener">红动中国</a></li><li><a href="https://cn.dreamstime.com/" target="_blank" rel="noopener">DreamsTime</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.huitu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汇图网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.quanjing.com/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="生活笔记" scheme="https://AIpynux.github.io/categories/%E7%94%9F%E6%B4%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="资源" scheme="https://AIpynux.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>配置Hexo主题之Melody</title>
    <link href="https://AIpynux.github.io/2019/02/03/%E9%85%8D%E7%BD%AEHexo%E4%B8%BB%E9%A2%98%E4%B9%8BMelody/"/>
    <id>https://AIpynux.github.io/2019/02/03/配置Hexo主题之Melody/</id>
    <published>2019-02-03T09:22:10.000Z</published>
    <updated>2019-02-26T11:26:47.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>使用Hexo的data file特性新建Melody主题的melody.yml配置文件后，<br>将个人博客部署到本地，输入本地URL后，浏览器没有响应，提示代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Unhandled rejection TypeError: /home/hgneer/Hexo/themes/melody/layout/includes/layout.pug:31</span><br><span class="line">    29|       each url in theme.stylesheets</span><br><span class="line">    30|         link(rel=&apos;stylesheet&apos;, href=url_for(url) + &apos;?version=&apos; + version())</span><br><span class="line">  &gt; 31|     each item in theme.cdn.css</span><br><span class="line">    32|       if item !== undefined</span><br><span class="line">    33|         link(rel=&apos;stylesheet&apos;, href=item + &apos;?version=&apos; + version())</span><br><span class="line">    34|     include ./head.pug</span><br><span class="line"></span><br><span class="line">Cannot read property &apos;css&apos; of undefined</span><br><span class="line">    at eval (eval at wrap (/home/hgneer/Hexo/node_modules/pug-runtime/wrap.js:6:10), &lt;anonymous&gt;:80:25)</span><br><span class="line">    at eval (eval at wrap (/home/hgneer/Hexo/node_modules/pug-runtime/wrap.js:6:10), &lt;anonymous&gt;:102:4)</span><br><span class="line">    at template (eval at wrap (/home/hgneer/Hexo/node_modules/pug-runtime/wrap.js:6:10), &lt;anonymous&gt;:1657:72)</span><br><span class="line">    at Theme._View.View._compiled.locals [as _compiled] (/home/hgneer/Hexo/node_modules/hexo/lib/theme/view.js:125:48)</span><br><span class="line">    at Theme._View.View.View.render (/home/hgneer/Hexo/node_modules/hexo/lib/theme/view.js:30:15)</span><br><span class="line">    at route.set (/home/hgneer/Hexo/node_modules/hexo/lib/hexo/index.js:394:29)</span><br><span class="line">    at tryCatcher (/home/hgneer/Hexo/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at /home/hgneer/Hexo/node_modules/bluebird/js/release/method.js:15:34</span><br><span class="line">    at RouteStream._read (/home/hgneer/Hexo/node_modules/hexo/lib/hexo/router.js:134:3)</span><br><span class="line">    at RouteStream.Readable.read (_stream_readable.js:452:10)</span><br><span class="line">    at resume_ (_stream_readable.js:899:12)</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:63:19)</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>需要复制到Hexo/source/_data下的_config.yml是melody主题目录下的而非Hexo目录下的。</p><h2 id="待用特性"><a href="#待用特性" class="headerlink" title="待用特性"></a>待用特性</h2><ul><li>Slide页面(利用reveal.js)</li><li>相册页面</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;遇到问题&quot;&gt;&lt;a href=&quot;#遇到问题&quot; class=&quot;headerlink&quot; title=&quot;遇到问题&quot;&gt;&lt;/a&gt;遇到问题&lt;/h2&gt;&lt;p&gt;使用Hexo的data file特性新建Melody主题的melody.yml配置文件后，&lt;br&gt;将个人博客部署到本地，输入
      
    
    </summary>
    
      <category term="编码笔记" scheme="https://AIpynux.github.io/categories/%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Hexo" scheme="https://AIpynux.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>可选发型</title>
    <link href="https://AIpynux.github.io/2019/01/31/%E5%8F%AF%E9%80%89%E5%8F%91%E5%9E%8B/"/>
    <id>https://AIpynux.github.io/2019/01/31/可选发型/</id>
    <published>2019-01-31T08:53:55.000Z</published>
    <updated>2019-02-03T08:46:27.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="短发"><a href="#短发" class="headerlink" title="短发"></a>短发</h3><ul><li>板寸</li><li>碎发</li><li>莫西干</li></ul><h3 id="中发"><a href="#中发" class="headerlink" title="中发"></a>中发</h3><ul><li>复古油头</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;短发&quot;&gt;&lt;a href=&quot;#短发&quot; class=&quot;headerlink&quot; title=&quot;短发&quot;&gt;&lt;/a&gt;短发&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;板寸&lt;/li&gt;
&lt;li&gt;碎发&lt;/li&gt;
&lt;li&gt;莫西干&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;中发&quot;&gt;&lt;a href=&quot;#中发&quot;
      
    
    </summary>
    
      <category term="生活笔记" scheme="https://AIpynux.github.io/categories/%E7%94%9F%E6%B4%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>为Github账户设置GPG认证</title>
    <link href="https://AIpynux.github.io/2019/01/31/%E4%B8%BAGithub%E8%B4%A6%E6%88%B7%E8%AE%BE%E7%BD%AEGPG%E8%AE%A4%E8%AF%81/"/>
    <id>https://AIpynux.github.io/2019/01/31/为Github账户设置GPG认证/</id>
    <published>2019-01-31T06:28:35.000Z</published>
    <updated>2019-02-04T04:11:18.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>GPG密钥算法旨在完成文件传输过程中的加密工作。</strong></p><p><em>Github支持的GPG密钥算法:</em></p><ul><li>RSA</li><li>ElGamal</li><li>DSA</li><li>ECDH</li><li>ECDSA</li><li>EdDSA</li></ul><p><em>为Github账户设置GPG认证的好处:</em></p><ol><li><p>可以限制使得对项目的commit必须经过认证后才能merge。</p></li><li><p>让项目使用者明晰哪些commit是官方认证哪些又是未经许可。</p></li></ol><a id="more"></a><h3 id="查看已有GPG密钥"><a href="#查看已有GPG密钥" class="headerlink" title="查看已有GPG密钥"></a>查看已有GPG密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-secret-keys --keyid-format LONG</span><br></pre></td></tr></table></figure><h3 id="创建GPG密钥"><a href="#创建GPG密钥" class="headerlink" title="创建GPG密钥"></a>创建GPG密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure><h3 id="添加密钥到Github账户"><a href="#添加密钥到Github账户" class="headerlink" title="添加密钥到Github账户"></a>添加密钥到Github账户</h3><p>查看已创建的密钥，从中选择要添加到Github的密钥ID是<strong>6DD5E93799EE33C7</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-secret-keys --keyid-format LONG</span><br><span class="line">/home/hgneer/.gnupg/secring.gpg</span><br><span class="line">-------------------------------</span><br><span class="line">sec   2048R/BCA9B4B1BA4C13CE 2017-04-05</span><br><span class="line">uid                          HeGuang (GPG key <span class="keyword">for</span> HeGuang) &lt;hgneer@gmail.com&gt;</span><br><span class="line">ssb   2048R/D0B0CD73B2553FBB 2017-04-05</span><br><span class="line"></span><br><span class="line">sec   4096R/6DD5E93799EE33C7 2019-01-31</span><br><span class="line">uid                          AIpynux (New World!) &lt;AIpynux@gmail.com&gt;</span><br><span class="line">ssb   4096R/2C344A43117B0512 2019-01-31</span><br></pre></td></tr></table></figure><p>使用如下命令将ID是<strong>6DD5E93799EE33C7</strong>的密钥的公钥输出到终端显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --<span class="built_in">export</span> 6DD5E93799EE33C7</span><br></pre></td></tr></table></figure><p>之后将得到的像下面格式一样的文本复制Github账户的GPG密钥设置框。</p><blockquote><p>—–BEGIN PGP PUBLIC KEY BLOCK—–<br>公钥内容<br>—–END PGP PUBLIC KEY BLOCK—–.</p></blockquote><h3 id="为本地Git设置全局GPG密钥ID"><a href="#为本地Git设置全局GPG密钥ID" class="headerlink" title="为本地Git设置全局GPG密钥ID"></a>为本地Git设置全局GPG密钥ID</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.signingkey 6DD5E93799EE33C7</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">GPG入门教程</a></p></li><li><p><a href="https://help.github.com/articles/managing-commit-signature-verification/" target="_blank" rel="noopener">Managing commit signature verification</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;GPG密钥算法旨在完成文件传输过程中的加密工作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Github支持的GPG密钥算法:&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSA&lt;/li&gt;
&lt;li&gt;ElGamal&lt;/li&gt;
&lt;li&gt;DSA&lt;/li&gt;
&lt;li&gt;ECDH&lt;/li&gt;
&lt;li&gt;ECDSA&lt;/li&gt;
&lt;li&gt;EdDSA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;为Github账户设置GPG认证的好处:&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以限制使得对项目的commit必须经过认证后才能merge。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;让项目使用者明晰哪些commit是官方认证哪些又是未经许可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="编码笔记" scheme="https://AIpynux.github.io/categories/%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://AIpynux.github.io/tags/Git/"/>
    
      <category term="GPG" scheme="https://AIpynux.github.io/tags/GPG/"/>
    
  </entry>
  
  <entry>
    <title>Vim无插件实现Markdown预览</title>
    <link href="https://AIpynux.github.io/2019/01/20/Vim%E6%97%A0%E6%8F%92%E4%BB%B6Markdown%E9%A2%84%E8%A7%88/"/>
    <id>https://AIpynux.github.io/2019/01/20/Vim无插件Markdown预览/</id>
    <published>2019-01-20T06:58:53.000Z</published>
    <updated>2019-02-02T04:11:50.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><em>chromium-browser</em></li><li><strong>Markdown Viewer</strong></li><li><strong><em>Ubuntu16.04</em></strong></li><li><del>Vim</del></li></ul><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>确保chromium-browser可以从终端输入命令启动。</li><li>为chromium安装Markdown Viewer插件</li><li>在~/.vimrc中添加如下代码:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;F4&gt; :call Preview()&lt;CR&gt;</span><br><span class="line">func! Preview()</span><br><span class="line">    if &amp;filetype == &apos;markdown.mkd&apos;</span><br><span class="line">        exec &quot;!chromium-browser %&quot;</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>用Vim编辑Markdown文件时按F4会打开一个chromium窗口进行预览,每次保存文件时更新预览。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Vim%E6%97%A0%E6%8F%92%E4%BB%B6Markdown%E9%A2%84%E8%A7%88/Vim%E6%97%A0%E6%8F%92%E4%BB%B6Markdown%E9%A2%84%E8%A7%88.png" alt=""></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>不要用Firefox，Firefox自动对离线文件的编码解析总不准确且不能修改默认的离线文件编码为Unicode，所以总是造成乱码。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Demorngel/article/details/72631234" target="_blank" rel="noopener">Vim无插件实现Markdown文件实时预览</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;chromium-browser&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Markdown Viewer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Ubuntu16.04&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Vim&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://AIpynux.github.io/categories/Tools/"/>
    
      <category term="Vim" scheme="https://AIpynux.github.io/categories/Tools/Vim/"/>
    
    
      <category term="Vim" scheme="https://AIpynux.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Improve the Speed of Git Clone from Github</title>
    <link href="https://AIpynux.github.io/2019/01/20/Improve_the_Speed_of_Git_Clone_from_Github/"/>
    <id>https://AIpynux.github.io/2019/01/20/Improve_the_Speed_of_Git_Clone_from_Github/</id>
    <published>2019-01-20T06:57:53.000Z</published>
    <updated>2019-02-04T04:22:54.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出现障碍"><a href="#出现障碍" class="headerlink" title="出现障碍"></a>出现障碍</h2><p>更新Vim到8.1后检查插件状态，发现ale需要重新安装。</p><p>用的插件管理器是Vim-Plug，在.vimrc.bundles中添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &apos;w0rp/ale&apos;</span><br></pre></td></tr></table></figure><p>之后在Vim中执行命令</p><blockquote><p>:PlugInstall</p></blockquote><p>看着屏幕上的进度条一点点地跑到终点，终端却抛来如下错误:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data remaining</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure><h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><p>看上诉错误的字面意思是下载的包在传输过程中提前结束。我以为凑巧出错便重新下载。</p><p>经过实验多次，这样的错误发生不是偶然。之后,经过查阅文档,我发现Vim-Plug实际上采</p><p>用git来下载安装Github上的插件项目。然而,国内用终端克隆Github上Repository速度特慢,</p><p>猜测此次障碍可能由此造成。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="1-为git设置代理"><a href="#1-为git设置代理" class="headerlink" title="1. 为git设置代理"></a>1. 为git设置代理</h3><p>在设置了SS代理的前提下，从终端输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><h3 id="2-修改Hosts"><a href="#2-修改Hosts" class="headerlink" title="2. 修改Hosts"></a>2. 修改Hosts</h3><p>用以下命令查找github.global.ssl.fastly.Net和github.com对应的IP地址:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nslookup github.global.ssl.fastly.Net</span><br><span class="line">nslookup github.com</span><br></pre></td></tr></table></figure></p><p>之后将IP地址和域名对添加到/etc/hosts文件。</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>git clone的速度从10.0KB/s提升到150.0KB/s;出现的插件下载安装障碍得到解决。</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/hzwwpgmwy/article/details/79043251" target="_blank" rel="noopener">git clone速度太慢解决方案</a></p><p><a href="https://www.zhihu.com/question/27159393" target="_blank" rel="noopener">git clone一个github上的仓库，太慢…</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;出现障碍&quot;&gt;&lt;a href=&quot;#出现障碍&quot; class=&quot;headerlink&quot; title=&quot;出现障碍&quot;&gt;&lt;/a&gt;出现障碍&lt;/h2&gt;&lt;p&gt;更新Vim到8.1后检查插件状态，发现ale需要重新安装。&lt;/p&gt;
&lt;p&gt;用的插件管理器是Vim-Plug，在.vimrc.bundles中添加:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Plug &amp;apos;w0rp/ale&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后在Vim中执行命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;:PlugInstall&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看着屏幕上的进度条一点点地跑到终点，终端却抛来如下错误:&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://AIpynux.github.io/categories/Tools/"/>
    
      <category term="Git" scheme="https://AIpynux.github.io/categories/Tools/Git/"/>
    
    
      <category term="Git" scheme="https://AIpynux.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04备份重装成根目录可扩容LVM方式Linux系统</title>
    <link href="https://AIpynux.github.io/2019/01/20/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%88%90%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9%E7%9A%84LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/"/>
    <id>https://AIpynux.github.io/2019/01/20/Ubuntu16.04备份重装成根目录可扩容的LVM方式Linux系统/</id>
    <published>2019-01-20T06:56:53.000Z</published>
    <updated>2019-02-04T01:57:19.880Z</updated>
    
    <content type="html"><![CDATA[<p><strong>说明:为了区分原先系统和重装后系统以及述说方便，将原先系统称作Ubuntu1，重装后系统称作Ubuntu2。</strong></p><p>先看一下我Ubuntu1的一些信息：<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image1.png" alt=""></p><a id="more"></a><h4 id="一、备份"><a href="#一、备份" class="headerlink" title="一、备份"></a>一、备份</h4><p>进入Ubuntu1，输入su root切换root，将设备/dev/sdb1（选一个你机器上有空余空间未挂载的分区）挂载到/tmp。<br>终端输入tar -cvpzf /tmp/back/back.tgz / –exclude=/proc –exclude=/lost+found –exclude=/tmp –exclude=/sys –exclude=/media。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image2.png" alt=""><br>将Ubuntu1上所有挂载在/目录下的文件(除了/目录下proc、lost+found、tmp、sys和media文件夹)压缩在已挂载/dev/sdb1设备的目录/tmp的back文件夹下，并命名为back.tgz。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1. /tmp下的back文件夹须事先创建。</span><br><span class="line">2. 备份时勿包括/dev/sdb1所挂载的目录（此处为/tmp）。</span><br><span class="line">3. 记下那些备份时未包括进来的目录（即proc等），最后恢复时需要手动mkdir创建，否则系统会出错。</span><br><span class="line">4. 最后压缩结束后可能会出现  tar: 由于前次错误，将以上次的错误状态退出。这个不用理会即可。</span><br></pre></td></tr></table></figure><h3 id="二、分配磁盘"><a href="#二、分配磁盘" class="headerlink" title="二、分配磁盘"></a>二、分配磁盘</h3><p>右击此电脑–&gt;管理<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image4.png" alt=""></p><p>得到计算机管理窗口–&gt;点击磁盘管理–&gt;右键单击选择要压缩的磁盘<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image5.png" alt=""></p><p>在<em>输入压缩空间量（MB）</em>里填写要压缩出的空间量,我这里压缩50G–&gt;压缩<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image6.png" alt=""></p><p>注：这里得到未分配的磁盘为待会我们用Linux进行LVM式分区做准备。<br>(电脑若有有空闲空间的设备直接跳过此步骤到第三步进行分区）</p><h3 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h3><p>制作Ubuntu16.04的U盘启动盘，进入试用即LiveCD模式。<br>首先在终端输入sudo passwd root，改变试用系统下root用户的密码。<br>之后输入su root切换成root用户，之后的大多操作都需要root权限。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image8.png" alt=""></p><p>  终端输入fdisk -l找到划分好有空闲空间的磁盘设备名。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image9.png" alt=""></p><p>我主机上有未分配磁盘空间的设备是/dev/sdb。所以终端输入fdisk /dev/sdb。输入n新建一个分区(/dev/sdb6)。<br>分区号为6–&gt;分区起始扇区按回车默认设置–&gt;分区终结扇区输入+49G，代表起始扇区往后数49G的扇区，意味给分区分配49G。<br>此分区待会制成lv时会分成给Ubuntu2的/、swap交换空间和/home对应的三个lv分区，此时先成一个就好,但需将分区类型标志改成LVM。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image10.png" alt=""></p><p>输入t改变分区标志–&gt;分区号为6–&gt;输入L查找代表LVM的代码–&gt;查得30代表LVM，输入30，修改标志成功。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image11.png" alt=""></p><p>输入n新建另一个分区(sdb7)对应给Ubuntu2的/boot，分配剩下的1G给此分区，此分区不需要改成LVM，不改标志。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image12.png" alt=""></p><p>输入p查看分区是否正确，确认无误后输入w写入并退出fdisk。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image13.png" alt=""></p><p>终端输入partprobe更新分区信息。再输入fdisk -l /dev/sdb查看分区创建成功否。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image14.png" alt=""></p><h3 id="四、创建PV、VG、LV"><a href="#四、创建PV、VG、LV" class="headerlink" title="四、创建PV、VG、LV"></a>四、创建PV、VG、LV</h3><p>终端输入pvcreate /dev/sdb6创建pv，输入pvscan查看目前有哪些pv检查创建成功否。<br>终端输入vgcreate hgneer1 /dev/sdb6创建名字为hgneer1（随自己定义的名字）的vg，输入vgscan查看目前有哪些pv检查创建成功否。<br>终端输入lvcreate -L +25G -n root hgneer1（刚才创建的vg），表示创建一个大小为25G的/dev/mapper/hgneer1-root的lv分区，预定作为Ubuntu2的/对应的分区。<br>终端输入lvcreate -L +8G -n swap hgneer1（刚才创建的vg），表示创建一个大小为8G的/dev/mapper/hgneer1-swap的lv分区，预定作为Ubuntu2的swap交换空间对应的分区。<br>终端输入lvcreate -L +16G -n home hgneer1（刚才创建的vg），表示创建一个大小为16G的/dev/mapper/hgneer1-home的lv分区，预定作为Ubuntu2的/home对应的分区。<br>终端输入lvscan检查所需lv创建成功否。确认无误后，lvm分区真正创建。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image15.png" alt=""></p><h3 id="五、重装系统"><a href="#五、重装系统" class="headerlink" title="五、重装系统"></a>五、重装系统</h3><p>点击桌面上的“install Ubuntu16.04.3 LTS”开始安装<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image16.png" alt=""></p><p><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image17.png" alt=""><br>安装时选择其他选项，自行分区选择调整。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image18.png" alt=""><br>/dev/mapper/hgneer1-home分区挂载到/home目录，选中格式化成Ext4日志文件系统<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image19.png" alt=""><br>/dev/mapper/hgneer1-root分区挂载到/目录，选中格式化成Ext4日志文件系统<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image20.png" alt=""><br>/dev/mapper/hgneer1-swap分区作为swap交换空间<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image21.png" alt=""><br>/dev/sdb7分区挂载到/boot目录，选中格式化成Ext4日志文件系统<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image22.png" alt=""><br>另外注意安装启动引导器的设备选择挂载到/boot目录的/dev/sdb7，否则很可能无法引导出Linux系统！！！<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image23.png" alt=""></p><p>等待安装成功后，先不要重启，继续试用，看新装上的系统Ubuntu2是否使用了LVM。<br>终端输入mount /dev/mapper/hgneer-root /mnt挂载Ubuntu2的/到试用系统的/mnt。<br>终端输入mount /dev/mapper/hgneer-home /mnt/home挂载Ubuntu2的/home到试用系统的/mnt/home。<br>终端输入mount /dev/sdb7 /mnt挂载Ubuntu2的/boot到试用系统的/mnt/boot。<br>cd到上面几个目录下看下，确定不为空系统成功装上后终端输入chroot /mnt将/mnt改成根目录，而后关机。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image24.png" alt=""></p><h3 id="六、恢复数据及配置"><a href="#六、恢复数据及配置" class="headerlink" title="六、恢复数据及配置"></a>六、恢复数据及配置</h3><p>重启进入Ubuntu2系统。将/etc/fstab文件及/boot目录备份到挂载了/dev/sdb1的/tmp的back文件夹中。<br>这些文件记载了Ubuntu2的启动信息以及Ubuntu2各重要目录所在的分区信息，<br>这些文件与Ubuntu1不一样的因此在之后解压备份文件后需要把这些文件替换到对应目录下。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image26.png" alt=""></p><p>  重启进入liveCD（U盘启动盘试用）。照前文一样命令获取试用系统的root权限。<br>  终端输入mount /dev/mapper/hgneer-root /mnt挂载Ubuntu2的/到试用系统的/mnt。<br>  终端输入mount /dev/mapper/hgneer-home /mnt/home挂载Ubuntu2的/home到试用系统的/mnt/home。<br>  终端输入mount /dev/sdb7 /mnt/boot挂载Ubuntu2的/boot到试用系统的/mnt/boot。<br>  cd到/mnt目录后，终端输入ls | xargs rm -rf，删除Ubuntu2系统根目录下的全部目录及文件。<br>  终端输入mount /dev/sdb1 /tmp挂载D盘到/tmp目录，cd到/tmp/back后终端输入tar -xvpf back.tgz -C /mnt。<br>  最终目的将Ubuntu1的备份下数据文件解压到/mnt即Ubuntu2的根目录下。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image27.png" alt=""></p><p><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image28.png" alt=""></p><p>等到解压完成后cd到/mnt后，终端输入mkdir proc lost+found tmp sys media，创建Ubuntu1备份时未选中的目录。<br>将备份在设备/dev/sdb1即现挂载在/tmp目录下的back文件夹中的fstab拷贝替换到/mnt/etc目录下。<br>将备份在设备/dev/sdb1即现挂载在/tmp目录下的back文件夹中的/boot文件夹中的文件拷贝到/mnt/boot目录下。<br>终端输入chroot /mnt转换/mnt当作根目录。<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image29.png" alt=""><br>重启进入Ubuntu2，根目录可扩容且用户数据配置与Ubuntu1完全一致的Linux系统完成！<br><img src="https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image30.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;说明:为了区分原先系统和重装后系统以及述说方便，将原先系统称作Ubuntu1，重装后系统称作Ubuntu2。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看一下我Ubuntu1的一些信息：&lt;br&gt;&lt;img src=&quot;https://github.com/AIpynux/Resource_of_Blogs/raw/master/Ubuntu16.04%E5%A4%87%E4%BB%BD%E9%87%8D%E8%A3%85%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8F%AF%E6%89%A9%E5%AE%B9LVM%E6%96%B9%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/image1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://AIpynux.github.io/categories/Linux/"/>
    
      <category term="Ubuntu" scheme="https://AIpynux.github.io/categories/Linux/Ubuntu/"/>
    
      <category term="磁盘阵列" scheme="https://AIpynux.github.io/categories/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
    
      <category term="LVM" scheme="https://AIpynux.github.io/categories/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/LVM/"/>
    
    
      <category term="Ubuntu" scheme="https://AIpynux.github.io/tags/Ubuntu/"/>
    
  </entry>
  
</feed>
